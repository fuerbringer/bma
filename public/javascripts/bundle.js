var bma =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/grid.js":
/*!*********************!*\
  !*** ./src/grid.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("document.createSvg = function(tagName) {\n  var svgNS = \"http://www.w3.org/2000/svg\";\n  return this.createElementNS(svgNS, tagName);\n};\n\nvar drawVisualPath =  function(pathMatrix, polyId, color, id) {\n  var id = id ? id : \"main-grid\";\n  var color = color ? color : \"green\";\n  var svg = document.getElementById(id);\n  var polyLine = document.createSvg(\"polyline\");\n  var points = \"\";\n  for (var i = 0; i < pathMatrix.length; i++){\n    if (pathMatrix[i] instanceof Array){\n      if(pathMatrix[i].length == 2) {\n        points += pathMatrix[i].join(\",\");\n        points += \" \";\n      }\n    }\n  }\n  polyLine.setAttribute(\"points\", points);\n  polyLine.setAttribute(\"fill\", \"none\");\n  polyLine.setAttribute(\"stroke\", color);\n  polyLine.setAttribute(\"class\", \"grid-path\");\n  if(polyId) {\n    polyLine.setAttribute(\"id\", \"grid-path\");\n  }\n  svg.appendChild(polyLine);\n}\n\n\n/**\n * Delete all paths\n */\nvar clearVisualPaths = function() {\n  var polys = document.getElementsByClassName(\"grid-path\");\n  while(polys[0]) {\n    polys[0].parentNode.removeChild(polys[0]);\n  }\n}\n\n\n/**\n * Given a rect#coord-N-N returns the parents <g> translate/transform x and y in an array\n * Example: [0, 16]\n */\nvar getSvgBoxCoord = function(id) {\n  // Assuming base element with id `id` has a parent with an attribute `transform`\n  var translate = document.getElementById(id).parentNode.getAttribute(\"transform\");\n  var parts = /translate\\(\\s*([^\\s,)]+)[ , ]([^\\s,)]+)/.exec(translate);\n  return [ parts[1], parts[2] ];\n}\n\n/**\n * Provides exact SVG pixel coordinates for a given box' <g> parent element\n * Example:\n *  let f(x) = x\n *  f(5) = x <=> getRealBoxCoords(5,5)\n *  Returns exact pixel coordinates for 5,5\n */\nvar getRealBoxCoords = function(x, y, centeringOffset) {\n  var id = \"coord-\" + x + \"-\" + y;\n  var centeringOffset = centeringOffset ? centeringOffset : { x: 0, y: 0 };\n  // Assuming base element with id `id` has a parent with an attribute `transform`\n  var translate = document.getElementById(id).parentNode.getAttribute(\"transform\");\n  var parts = /translate\\(\\s*([^\\s,)]+)[ , ]([^\\s,)]+)/.exec(translate);\n  return [ parseInt(parts[1]) + centeringOffset.x, parseInt(parts[2]) + centeringOffset.y ];\n}\n\n\n/**\n * Example:\n *  // Fills box at 1,1 with red color\n *  setRectAttribute(1, 1, \"fill\", \"red\");\n */\nvar setRectAttribute = function(x, y, name, value) {\n  var rect = document.getElementById(\"coord-\" + x + \"-\" + y);\n  rect.setAttribute(name, value);\n}\n\n\n/**\n * Resets all boxes in the coordinate system with class coord-rect to default\n * Example:\n *  // Set rect at 1,1 to filled red ...\n *  setRectAttribute(1, 1, \"fill\", \"red\");\n *  // And reset it again (the whole grid)\n *  resetAllCoordRects();\n */\nvar resetAllCoordRects = function() {\n  var rects = document.getElementsByClassName(\"coord-rect\");\n  for(var i = 0; i < rects.length; i++) {\n    rects[i].setAttribute(\"fill\", \"white\");\n    rects[i].setAttribute(\"stroke\", \"black\"); \n    rects[i].setAttribute(\"stroke-width\", \"0.1\"); \n  }\n}\n\n\n/**\n * Resets rect at x,y to its initial state\n */\nvar resetCoordRect = function(x, y) {\n  var rect = document.getElementById(\"coord-\" + x + \"-\" + y);\n  rect.setAttribute(\"fill\", \"white\");\n  rect.setAttribute(\"stroke\", \"black\"); \n  rect.setAttribute(\"stroke-width\", \"0.1\"); \n}\n\n\n/**\n * @param {int} size Height / width attribute for inner boxes\n * @param {int} pixelsPerSide Total width and height of the output\n */\nvar generateGridFromMatrix = function(matrix, size, pixelsPerSide, id) {\n  var size = size ? size : 10;\n  var pixelsPerSide = pixelsPerSide ? pixelsPerSide : 400;\n  var id = id ? id : \"main-grid\";\n  var svg = document.createSvg(\"svg\");\n  svg.setAttribute(\"id\", id);\n  svg.setAttribute(\"width\", pixelsPerSide);\n  svg.setAttribute(\"height\", pixelsPerSide);\n  svg.setAttribute(\"viewBox\", [0, 0, matrix.length * size, matrix[0].length * size].join(\" \"));\n\n  for(var y = 0; y < matrix.length; y++) {\n    for(var x = 0; x < matrix[y].length; x++) {\n      var g = document.createSvg(\"g\"); // Group element we want to act as parent\n      g.setAttribute(\"transform\", [ \"translate(\", x * size, \",\", y * size, \")\" ].join(\"\"));\n\n      var number = matrix.length * y + x;\n      // Create individual cell so we can display it and modify it later\n      var box = document.createSvg(\"rect\"); \n      box.setAttribute(\"width\", size);\n      box.setAttribute(\"height\", size);\n      if(matrix[y][x] == 1) {\n        box.setAttribute(\"fill\", \"grey\");\n      } else if(matrix[y][x] == \"s\") {\n        box.setAttribute(\"fill\", \"blue\");\n      } else if(matrix[y][x] == \"f\") {\n        box.setAttribute(\"fill\", \"green\");\n      } else {\n        box.setAttribute(\"fill\", \"white\");\n      }\n      box.setAttribute(\"id\", \"coord-\" + x + \"-\" + y); \n      box.setAttribute(\"class\", \"coord-rect\");\n      box.setAttribute(\"stroke\", \"black\"); \n      box.setAttribute(\"stroke-width\", \"0.1\"); \n      g.appendChild(box);\n      svg.appendChild(g);\n    }  \n  }\n  return svg;\n}\n\n\nmodule.exports = {\n  drawVisualPath,\n  clearVisualPaths,\n  getSvgBoxCoord,\n  getRealBoxCoords,\n  setRectAttribute,\n  resetAllCoordRects,\n  resetCoordRect,\n  generateGridFromMatrix\n}\n\n\n//# sourceURL=webpack://bma/./src/grid.js?");

/***/ }),

/***/ "./src/helper.js":
/*!***********************!*\
  !*** ./src/helper.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var randomIntFromInterval = function(min, max) {\n  return Math.floor(Math.random() * (max - min+1) + min);\n}\n\n\n/**\n * Finds \"s\" and \"f\" inside a 2d matrix, representing start and finish, and returns their coords.\n */\nvar findStartAndFinish = function(matrix) {\n  var startAndFinish = {\n    start: {\n      x: false,\n      y: false\n    },\n    finish: {\n      x: false, y: false\n    }\n  };\n  for(var y = 0; y < matrix.length; y++) {\n    for(var x = 0; x < matrix[y].length; x++) {\n      if(matrix[y][x] === \"s\") {\n        startAndFinish.start.x = x;\n        startAndFinish.start.y = y;\n      } else if(matrix[y][x] === \"f\") {\n        startAndFinish.finish.x = x;\n        startAndFinish.finish.y = y;\n      }\n    }\n  }\n  return startAndFinish;\n}\n\n/**\n * Prepares a 2d matrix for PathFinding.js\n * Removes Start and Finish (\"s\", \"f\") elements\n */\nvar sanitizeMatrix = function(matrix) {\n  for(var y = 0; y < matrix.length; y++) {\n    for(var x = 0; x < matrix[y].length; x++) {\n      if(matrix[y][x] != 0 && matrix[y][x] != 1) {\n        matrix[y][x] = 0;\n      }\n    }\n  }\n  return matrix;\n}\n\nvar setStatus = function(options) {\n  if(options.hasOwnProperty(\"startAndFinish\")) {\n    document.getElementById('stat-start').innerHTML\n      = '`S(' + options.startAndFinish.start.x + ', ' + options.startAndFinish.start.y + ')`';\n    document.getElementById('stat-end').innerHTML\n      = '`F(' + options.startAndFinish.finish.x + ', ' + options.startAndFinish.finish.y + ')`';\n  }\n  if(options.hasOwnProperty(\"distance\")) {\n    document.getElementById('stat-distance').innerHTML = '`'\n      + options.distance\n      + (options.distance == 1 ? '` Zelle' : '` Zellen');\n  }\n}\n\nmodule.exports = {\n  randomIntFromInterval,\n  findStartAndFinish,\n  sanitizeMatrix,\n  setStatus\n}\n\n\n//# sourceURL=webpack://bma/./src/helper.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var helper = __webpack_require__(/*! ./helper */ \"./src/helper.js\")\nvar grid = __webpack_require__(/*! ./grid */ \"./src/grid.js\")\nvar maze = __webpack_require__(/*! ./maze */ \"./src/maze.js\")\nvar pathFinding = __webpack_require__(/*! ./pathfinding.js */ \"./src/pathfinding.js\")\n\nvar aStarDemo = function(options) {\n  //console.debug(generateRecBacktrackerMaze(6, 6));\n  //var matrix = generatePseudoRandomMaze(20, 20);\n  var matrix = maze.generateRecBacktrackerMaze(24, 24, false);\n  var container = document.getElementById(\"container\");\n  container.appendChild(grid.generateGridFromMatrix(matrix));\n  var startAndFinish = helper.findStartAndFinish(matrix);\n  var polyLine = [];\n  var dbgWnd = document.getElementById(\"debug-out\");\n  var pfGrid = new pathFinding.Grid(helper.sanitizeMatrix(matrix));\n  var finder = new pathFinding.AStarFinder({\n    allowDiagonal: options.allowDiagonal ? true : false,\n    heuristic: function(dx, dy) {\n      // Tap into individual steps if needed\n      return pathFinding.Heuristic.chebyshev(dx, dy);\n    }\n  });\n  var path = finder.findPath(\n    startAndFinish.start.x, startAndFinish.start.y,\n    startAndFinish.finish.x, startAndFinish.finish.y, pfGrid);\n  for(var i = 0; i < path.length; i++) {\n    polyLine.push(grid.getRealBoxCoords(path[i][0], path[i][1], { x: 4, y: 4 }));\n  }\n  grid.drawVisualPath(polyLine);\n\n  helper.setStatus({\n    startAndFinish: startAndFinish,\n    distance: (path.length - 1)\n  });\n}\n\nvar aStarDemoControls = function() {\n  document.getElementById('dropdown-diagonal-y').addEventListener(\"click\", function() {\n    var container = document.getElementById(\"container\");\n    container.innerHTML = '';\n    bma.aStarDemo({ allowDiagonal: true });\n    MathJax.Hub.Typeset();\n  });\n  document.getElementById('dropdown-diagonal-n').addEventListener(\"click\", function() {\n    var container = document.getElementById(\"container\");\n    container.innerHTML = '';\n    bma.aStarDemo({ allowDiagonal: false });\n    MathJax.Hub.Typeset();\n  });\n}\n\nmodule.exports = {\n  aStarDemo,\n  aStarDemoControls,\n}\n\n\n//# sourceURL=webpack://bma/./src/index.js?");

/***/ }),

/***/ "./src/maze.js":
/*!*********************!*\
  !*** ./src/maze.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var helper = __webpack_require__(/*! ./helper */ \"./src/helper.js\")\n\n\nvar generatePseudoRandomMaze = function(width, height, remainderFrequency) {\n  var matrix = [];\n  remainderFrequency = remainderFrequency ? remainderFrequency : 4;\n  for(var y = 0; y < height; y++) {\n    var row = [];\n    for(var x = 0; x < width; x++) {\n      var block = (((Math.random() * 100) % remainderFrequency).toFixed(0) == true) ? 1 : 0;\n      row.push(block);\n    }\n    matrix.push(row);\n  }\n  var startBlock = {\n    x: Math.floor(Math.random() * width),\n    y: Math.floor(Math.random() * height),\n  };\n  var endBlock = {\n    x: Math.floor(Math.random() * width),\n    y: Math.floor(Math.random() * height),\n  };\n  matrix[startBlock.y][startBlock.x] = 's';\n  matrix[endBlock.y][endBlock.x] = 'f';\n  return matrix;\n}\n\n\nvar markStartAndFinish = function(matrix, randomSelection) {\n  var possible = [];\n  for(var y = 0; y < matrix.length; y++) {\n    for(var x = 0; x < matrix[y].length; x++) {\n      if(matrix[y][x] == 0) {\n        possible.push({ x: x, y: y });\n      }\n    }\n  }\n  var chosenStart = Math.floor(Math.random() * possible.length);\n  if(randomSelection) {\n    matrix[possible[chosenStart].y][possible[chosenStart].x] = 's';\n  } else {\n    matrix[possible[0].y][possible[0].x] = 's';\n  }\n  possible.splice(chosenStart, 1);\n  var chosenFinish = Math.floor(Math.random() * possible.length);\n  if(randomSelection) {\n    matrix[possible[chosenFinish].y][possible[chosenFinish].x] = 'f';\n  } else {\n    matrix[possible[possible.length - 1].y][possible[possible.length - 1].x] = 'f';\n  }\n  return matrix;\n}\n\n\n/**\n * Pseudocode from https://en.wikipedia.org/wiki/Maze_generation#Recursive_backtracker\n */\nvar generateRecBacktrackerMaze = function(width, height, randomStartAndFinish) {\n  // Border wall deltas\n  width += 2;\n  height += 2;\n  var matrix = [];\n  for(var y = 0; y < height - 1; y++) {\n    var row = [];\n    for(var x = 0; x < width - 1; x++) {\n      var block = 0;\n    }\n    matrix.push(row);\n  }\n\n  // Rest of the function body by https://github.com/semibran/maze\n  function generate(nodes, adjacent, choose) {\n    var node = choose(nodes)\n    var stack = [node]\n    var maze = new Map()\n    for (var node of nodes) {\n      maze.set(node, [])\n    }\n    while (node) {\n      var neighbors = nodes.filter(other => !maze.get(other).length && adjacent(node, other))\n      if (neighbors.length) {\n        var neighbor = choose(neighbors)\n        maze.get(node).push(neighbor)\n        maze.get(neighbor).push(node)\n        stack.unshift(neighbor)\n        node = neighbor\n\n      } else {\n        stack.shift()\n        node = stack[0]\n      }\n    }\n    return maze\n  }\n\n  var world = {\n    width: width - 1,\n    height: height - 1,\n    tiles: new Array((width - 1) * (height - 1)).fill('wall')\n  }\n\n  var nodes = cells(world).filter(cell => cell.x % 2 && cell.y % 2)\n  var maze = generate(nodes, adjacent, choose)\n  connect(maze, world)\n\n  function cells(grid) {\n    var { width, height  } = grid\n    var cells = new Array(width * height)\n    for (var y = 0; y < height; y++) {\n      for (var x = 0; x < width; x++) {\n        var cell = { x, y  }\n        cells[locate(grid, cell)] = cell\n      }\n    }\n    return cells\n  }\n\n  function locate(grid, cell) {\n    return cell.y * grid.width + cell.x\n\n  }\n\n  function adjacent(a, b) {\n    return Math.abs(b.x - a.x) + Math.abs(b.y - a.y) === 2\n  }\n\n  function choose(array) {\n    return array[Math.floor(Math.random() * array.length)]\n  }\n\n  function connect(maze, world) {\n    for (var [node, neighbors] of maze) {\n      world.tiles[locate(world, node)] = 'floor'\n      for (var neighbor of neighbors) {\n        var midpoint = {\n          x: node.x + (neighbor.x - node.x) / 2,\n          y: node.y + (neighbor.y - node.y) / 2\n        }\n        world.tiles[locate(world, midpoint)] = 'floor'\n      }\n    }\n  }\n\n  var x = 0;\n  var y = 0;\n  for (var cell of cells(world)) {\n    var tile = world.tiles[locate(world, cell)]\n    if (!cell.x && cell.y) {\n      y++;\n      x = 0;\n    } else {\n      x++;\n    }\n    if(x < width - 1 && y < height) {\n      matrix[y][x] = (tile == 'wall' ? 1 : 0);\n    }\n  }\n\n  var corridors = [];\n  for(var y = 1; y < height - 1; y++) {\n    for(var x = 1; x < width - 1; x++) {\n      if(matrix[y][x] == 0) {\n        corridors.push({ x: x, y: y });\n      }\n    }\n  }\n\n  // Random start\n  var startIndex = helper.randomIntFromInterval(0, corridors.length - 1);\n  var start = corridors[startIndex];\n  // Remove start element so start and finish don't end up as the same cell\n  corridors.splice(startIndex, 1);\n  var finishIndex = helper.randomIntFromInterval(0, corridors.length - 1);\n  var finish = corridors[finishIndex];\n  matrix[start.y][start.x] = 's';\n  matrix[finish.y][finish.x] = 'f';\n  matrix[0][0] = 1; // Patch wall at (0,0)\n  return matrix;\n}\n\n\nmodule.exports = {\n  generatePseudoRandomMaze,\n  markStartAndFinish,\n  generateRecBacktrackerMaze\n}\n\n\n//# sourceURL=webpack://bma/./src/maze.js?");

/***/ }),

/***/ "./src/pathfinding.js":
/*!****************************!*\
  !*** ./src/pathfinding.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var require;var require;/**\n *    ____       _   _     _____ _           _ _                _         \n *   |  _ \\ __ _| |_| |__ |  ___(_)_ __   __| (_)_ __   __ _   (_)___     \n *   | |_) / _` | __| '_ \\| |_  | | '_ \\ / _` | | '_ \\ / _` |  | / __|    \n *   |  __/ (_| | |_| | | |  _| | | | | | (_| | | | | | (_| |_ | \\__ \\    \n *   |_|   \\__,_|\\__|_| |_|_|   |_|_| |_|\\__,_|_|_| |_|\\__, (_)/ |___/    \n *                                                     |___/ |__/         \n *   https://github.com/qiao/PathFinding.js\n */\n\n!function(e){if(true)module.exports=e();else { var f; }}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return require(o,!0);if(i)return i(o,!0);throw new Error(\"Cannot find module '\"+o+\"'\")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){\nmodule.exports = _dereq_('./lib/heap');\n\n},{\"./lib/heap\":2}],2:[function(_dereq_,module,exports){\n// Generated by CoffeeScript 1.8.0\n(function() {\n  var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;\n\n  floor = Math.floor, min = Math.min;\n\n\n  /*\n  Default comparison function to be used\n   */\n\n  defaultCmp = function(x, y) {\n    if (x < y) {\n      return -1;\n    }\n    if (x > y) {\n      return 1;\n    }\n    return 0;\n  };\n\n\n  /*\n  Insert item x in list a, and keep it sorted assuming a is sorted.\n  \n  If x is already in a, insert it to the right of the rightmost x.\n  \n  Optional args lo (default 0) and hi (default a.length) bound the slice\n  of a to be searched.\n   */\n\n  insort = function(a, x, lo, hi, cmp) {\n    var mid;\n    if (lo == null) {\n      lo = 0;\n    }\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (lo < 0) {\n      throw new Error('lo must be non-negative');\n    }\n    if (hi == null) {\n      hi = a.length;\n    }\n    while (lo < hi) {\n      mid = floor((lo + hi) / 2);\n      if (cmp(x, a[mid]) < 0) {\n        hi = mid;\n      } else {\n        lo = mid + 1;\n      }\n    }\n    return ([].splice.apply(a, [lo, lo - lo].concat(x)), x);\n  };\n\n\n  /*\n  Push item onto heap, maintaining the heap invariant.\n   */\n\n  heappush = function(array, item, cmp) {\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    array.push(item);\n    return _siftdown(array, 0, array.length - 1, cmp);\n  };\n\n\n  /*\n  Pop the smallest item off the heap, maintaining the heap invariant.\n   */\n\n  heappop = function(array, cmp) {\n    var lastelt, returnitem;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    lastelt = array.pop();\n    if (array.length) {\n      returnitem = array[0];\n      array[0] = lastelt;\n      _siftup(array, 0, cmp);\n    } else {\n      returnitem = lastelt;\n    }\n    return returnitem;\n  };\n\n\n  /*\n  Pop and return the current smallest value, and add the new item.\n  \n  This is more efficient than heappop() followed by heappush(), and can be\n  more appropriate when using a fixed size heap. Note that the value\n  returned may be larger than item! That constrains reasonable use of\n  this routine unless written as part of a conditional replacement:\n      if item > array[0]\n        item = heapreplace(array, item)\n   */\n\n  heapreplace = function(array, item, cmp) {\n    var returnitem;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    returnitem = array[0];\n    array[0] = item;\n    _siftup(array, 0, cmp);\n    return returnitem;\n  };\n\n\n  /*\n  Fast version of a heappush followed by a heappop.\n   */\n\n  heappushpop = function(array, item, cmp) {\n    var _ref;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (array.length && cmp(array[0], item) < 0) {\n      _ref = [array[0], item], item = _ref[0], array[0] = _ref[1];\n      _siftup(array, 0, cmp);\n    }\n    return item;\n  };\n\n\n  /*\n  Transform list into a heap, in-place, in O(array.length) time.\n   */\n\n  heapify = function(array, cmp) {\n    var i, _i, _j, _len, _ref, _ref1, _results, _results1;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    _ref1 = (function() {\n      _results1 = [];\n      for (var _j = 0, _ref = floor(array.length / 2); 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j--){ _results1.push(_j); }\n      return _results1;\n    }).apply(this).reverse();\n    _results = [];\n    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n      i = _ref1[_i];\n      _results.push(_siftup(array, i, cmp));\n    }\n    return _results;\n  };\n\n\n  /*\n  Update the position of the given item in the heap.\n  This function should be called every time the item is being modified.\n   */\n\n  updateItem = function(array, item, cmp) {\n    var pos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    pos = array.indexOf(item);\n    if (pos === -1) {\n      return;\n    }\n    _siftdown(array, 0, pos, cmp);\n    return _siftup(array, pos, cmp);\n  };\n\n\n  /*\n  Find the n largest elements in a dataset.\n   */\n\n  nlargest = function(array, n, cmp) {\n    var elem, result, _i, _len, _ref;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    result = array.slice(0, n);\n    if (!result.length) {\n      return result;\n    }\n    heapify(result, cmp);\n    _ref = array.slice(n);\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      elem = _ref[_i];\n      heappushpop(result, elem, cmp);\n    }\n    return result.sort(cmp).reverse();\n  };\n\n\n  /*\n  Find the n smallest elements in a dataset.\n   */\n\n  nsmallest = function(array, n, cmp) {\n    var elem, i, los, result, _i, _j, _len, _ref, _ref1, _results;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (n * 10 <= array.length) {\n      result = array.slice(0, n).sort(cmp);\n      if (!result.length) {\n        return result;\n      }\n      los = result[result.length - 1];\n      _ref = array.slice(n);\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        elem = _ref[_i];\n        if (cmp(elem, los) < 0) {\n          insort(result, elem, 0, null, cmp);\n          result.pop();\n          los = result[result.length - 1];\n        }\n      }\n      return result;\n    }\n    heapify(array, cmp);\n    _results = [];\n    for (i = _j = 0, _ref1 = min(n, array.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {\n      _results.push(heappop(array, cmp));\n    }\n    return _results;\n  };\n\n  _siftdown = function(array, startpos, pos, cmp) {\n    var newitem, parent, parentpos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    newitem = array[pos];\n    while (pos > startpos) {\n      parentpos = (pos - 1) >> 1;\n      parent = array[parentpos];\n      if (cmp(newitem, parent) < 0) {\n        array[pos] = parent;\n        pos = parentpos;\n        continue;\n      }\n      break;\n    }\n    return array[pos] = newitem;\n  };\n\n  _siftup = function(array, pos, cmp) {\n    var childpos, endpos, newitem, rightpos, startpos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    endpos = array.length;\n    startpos = pos;\n    newitem = array[pos];\n    childpos = 2 * pos + 1;\n    while (childpos < endpos) {\n      rightpos = childpos + 1;\n      if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) {\n        childpos = rightpos;\n      }\n      array[pos] = array[childpos];\n      pos = childpos;\n      childpos = 2 * pos + 1;\n    }\n    array[pos] = newitem;\n    return _siftdown(array, startpos, pos, cmp);\n  };\n\n  Heap = (function() {\n    Heap.push = heappush;\n\n    Heap.pop = heappop;\n\n    Heap.replace = heapreplace;\n\n    Heap.pushpop = heappushpop;\n\n    Heap.heapify = heapify;\n\n    Heap.updateItem = updateItem;\n\n    Heap.nlargest = nlargest;\n\n    Heap.nsmallest = nsmallest;\n\n    function Heap(cmp) {\n      this.cmp = cmp != null ? cmp : defaultCmp;\n      this.nodes = [];\n    }\n\n    Heap.prototype.push = function(x) {\n      return heappush(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.pop = function() {\n      return heappop(this.nodes, this.cmp);\n    };\n\n    Heap.prototype.peek = function() {\n      return this.nodes[0];\n    };\n\n    Heap.prototype.contains = function(x) {\n      return this.nodes.indexOf(x) !== -1;\n    };\n\n    Heap.prototype.replace = function(x) {\n      return heapreplace(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.pushpop = function(x) {\n      return heappushpop(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.heapify = function() {\n      return heapify(this.nodes, this.cmp);\n    };\n\n    Heap.prototype.updateItem = function(x) {\n      return updateItem(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.clear = function() {\n      return this.nodes = [];\n    };\n\n    Heap.prototype.empty = function() {\n      return this.nodes.length === 0;\n    };\n\n    Heap.prototype.size = function() {\n      return this.nodes.length;\n    };\n\n    Heap.prototype.clone = function() {\n      var heap;\n      heap = new Heap();\n      heap.nodes = this.nodes.slice(0);\n      return heap;\n    };\n\n    Heap.prototype.toArray = function() {\n      return this.nodes.slice(0);\n    };\n\n    Heap.prototype.insert = Heap.prototype.push;\n\n    Heap.prototype.top = Heap.prototype.peek;\n\n    Heap.prototype.front = Heap.prototype.peek;\n\n    Heap.prototype.has = Heap.prototype.contains;\n\n    Heap.prototype.copy = Heap.prototype.clone;\n\n    return Heap;\n\n  })();\n\n  if (typeof module !== \"undefined\" && module !== null ? module.exports : void 0) {\n    module.exports = Heap;\n  } else {\n    window.Heap = Heap;\n  }\n\n}).call(this);\n\n},{}],3:[function(_dereq_,module,exports){\nvar DiagonalMovement = {\n    Always: 1,\n    Never: 2,\n    IfAtMostOneObstacle: 3,\n    OnlyWhenNoObstacles: 4\n};\n\nmodule.exports = DiagonalMovement;\n},{}],4:[function(_dereq_,module,exports){\nvar Node = _dereq_('./Node');\nvar DiagonalMovement = _dereq_('./DiagonalMovement');\n\n/**\n * The Grid class, which serves as the encapsulation of the layout of the nodes.\n * @constructor\n * @param {number|Array<Array<(number|boolean)>>} width_or_matrix Number of columns of the grid, or matrix\n * @param {number} height Number of rows of the grid.\n * @param {Array<Array<(number|boolean)>>} [matrix] - A 0-1 matrix\n *     representing the walkable status of the nodes(0 or false for walkable).\n *     If the matrix is not supplied, all the nodes will be walkable.  */\nfunction Grid(width_or_matrix, height, matrix) {\n    var width;\n\n    if (typeof width_or_matrix !== 'object') {\n        width = width_or_matrix;\n    } else {\n        height = width_or_matrix.length;\n        width = width_or_matrix[0].length;\n        matrix = width_or_matrix;\n    }\n\n    /**\n     * The number of columns of the grid.\n     * @type number\n     */\n    this.width = width;\n    /**\n     * The number of rows of the grid.\n     * @type number\n     */\n    this.height = height;\n\n    /**\n     * A 2D array of nodes.\n     */\n    this.nodes = this._buildNodes(width, height, matrix);\n}\n\n/**\n * Build and return the nodes.\n * @private\n * @param {number} width\n * @param {number} height\n * @param {Array<Array<number|boolean>>} [matrix] - A 0-1 matrix representing\n *     the walkable status of the nodes.\n * @see Grid\n */\nGrid.prototype._buildNodes = function(width, height, matrix) {\n    var i, j,\n        nodes = new Array(height);\n\n    for (i = 0; i < height; ++i) {\n        nodes[i] = new Array(width);\n        for (j = 0; j < width; ++j) {\n            nodes[i][j] = new Node(j, i);\n        }\n    }\n\n\n    if (matrix === undefined) {\n        return nodes;\n    }\n\n    if (matrix.length !== height || matrix[0].length !== width) {\n        throw new Error('Matrix size does not fit');\n    }\n\n    for (i = 0; i < height; ++i) {\n        for (j = 0; j < width; ++j) {\n            if (matrix[i][j]) {\n                // 0, false, null will be walkable\n                // while others will be un-walkable\n                nodes[i][j].walkable = false;\n            }\n        }\n    }\n\n    return nodes;\n};\n\n\nGrid.prototype.getNodeAt = function(x, y) {\n    return this.nodes[y][x];\n};\n\n\n/**\n * Determine whether the node at the given position is walkable.\n * (Also returns false if the position is outside the grid.)\n * @param {number} x - The x coordinate of the node.\n * @param {number} y - The y coordinate of the node.\n * @return {boolean} - The walkability of the node.\n */\nGrid.prototype.isWalkableAt = function(x, y) {\n    return this.isInside(x, y) && this.nodes[y][x].walkable;\n};\n\n\n/**\n * Determine whether the position is inside the grid.\n * XXX: `grid.isInside(x, y)` is wierd to read.\n * It should be `(x, y) is inside grid`, but I failed to find a better\n * name for this method.\n * @param {number} x\n * @param {number} y\n * @return {boolean}\n */\nGrid.prototype.isInside = function(x, y) {\n    return (x >= 0 && x < this.width) && (y >= 0 && y < this.height);\n};\n\n\n/**\n * Set whether the node on the given position is walkable.\n * NOTE: throws exception if the coordinate is not inside the grid.\n * @param {number} x - The x coordinate of the node.\n * @param {number} y - The y coordinate of the node.\n * @param {boolean} walkable - Whether the position is walkable.\n */\nGrid.prototype.setWalkableAt = function(x, y, walkable) {\n    this.nodes[y][x].walkable = walkable;\n};\n\n\n/**\n * Get the neighbors of the given node.\n *\n *     offsets      diagonalOffsets:\n *  +---+---+---+    +---+---+---+\n *  |   | 0 |   |    | 0 |   | 1 |\n *  +---+---+---+    +---+---+---+\n *  | 3 |   | 1 |    |   |   |   |\n *  +---+---+---+    +---+---+---+\n *  |   | 2 |   |    | 3 |   | 2 |\n *  +---+---+---+    +---+---+---+\n *\n *  When allowDiagonal is true, if offsets[i] is valid, then\n *  diagonalOffsets[i] and\n *  diagonalOffsets[(i + 1) % 4] is valid.\n * @param {Node} node\n * @param {DiagonalMovement} diagonalMovement\n */\nGrid.prototype.getNeighbors = function(node, diagonalMovement) {\n    var x = node.x,\n        y = node.y,\n        neighbors = [],\n        s0 = false, d0 = false,\n        s1 = false, d1 = false,\n        s2 = false, d2 = false,\n        s3 = false, d3 = false,\n        nodes = this.nodes;\n\n    // ↑\n    if (this.isWalkableAt(x, y - 1)) {\n        neighbors.push(nodes[y - 1][x]);\n        s0 = true;\n    }\n    // →\n    if (this.isWalkableAt(x + 1, y)) {\n        neighbors.push(nodes[y][x + 1]);\n        s1 = true;\n    }\n    // ↓\n    if (this.isWalkableAt(x, y + 1)) {\n        neighbors.push(nodes[y + 1][x]);\n        s2 = true;\n    }\n    // ←\n    if (this.isWalkableAt(x - 1, y)) {\n        neighbors.push(nodes[y][x - 1]);\n        s3 = true;\n    }\n\n    if (diagonalMovement === DiagonalMovement.Never) {\n        return neighbors;\n    }\n\n    if (diagonalMovement === DiagonalMovement.OnlyWhenNoObstacles) {\n        d0 = s3 && s0;\n        d1 = s0 && s1;\n        d2 = s1 && s2;\n        d3 = s2 && s3;\n    } else if (diagonalMovement === DiagonalMovement.IfAtMostOneObstacle) {\n        d0 = s3 || s0;\n        d1 = s0 || s1;\n        d2 = s1 || s2;\n        d3 = s2 || s3;\n    } else if (diagonalMovement === DiagonalMovement.Always) {\n        d0 = true;\n        d1 = true;\n        d2 = true;\n        d3 = true;\n    } else {\n        throw new Error('Incorrect value of diagonalMovement');\n    }\n\n    // ↖\n    if (d0 && this.isWalkableAt(x - 1, y - 1)) {\n        neighbors.push(nodes[y - 1][x - 1]);\n    }\n    // ↗\n    if (d1 && this.isWalkableAt(x + 1, y - 1)) {\n        neighbors.push(nodes[y - 1][x + 1]);\n    }\n    // ↘\n    if (d2 && this.isWalkableAt(x + 1, y + 1)) {\n        neighbors.push(nodes[y + 1][x + 1]);\n    }\n    // ↙\n    if (d3 && this.isWalkableAt(x - 1, y + 1)) {\n        neighbors.push(nodes[y + 1][x - 1]);\n    }\n\n    return neighbors;\n};\n\n\n/**\n * Get a clone of this grid.\n * @return {Grid} Cloned grid.\n */\nGrid.prototype.clone = function() {\n    var i, j,\n\n        width = this.width,\n        height = this.height,\n        thisNodes = this.nodes,\n\n        newGrid = new Grid(width, height),\n        newNodes = new Array(height);\n\n    for (i = 0; i < height; ++i) {\n        newNodes[i] = new Array(width);\n        for (j = 0; j < width; ++j) {\n            newNodes[i][j] = new Node(j, i, thisNodes[i][j].walkable);\n        }\n    }\n\n    newGrid.nodes = newNodes;\n\n    return newGrid;\n};\n\nmodule.exports = Grid;\n\n},{\"./DiagonalMovement\":3,\"./Node\":6}],5:[function(_dereq_,module,exports){\n/**\n * @namespace PF.Heuristic\n * @description A collection of heuristic functions.\n */\nmodule.exports = {\n\n  /**\n   * Manhattan distance.\n   * @param {number} dx - Difference in x.\n   * @param {number} dy - Difference in y.\n   * @return {number} dx + dy\n   */\n  manhattan: function(dx, dy) {\n      return dx + dy;\n  },\n\n  /**\n   * Euclidean distance.\n   * @param {number} dx - Difference in x.\n   * @param {number} dy - Difference in y.\n   * @return {number} sqrt(dx * dx + dy * dy)\n   */\n  euclidean: function(dx, dy) {\n      return Math.sqrt(dx * dx + dy * dy);\n  },\n\n  /**\n   * Octile distance.\n   * @param {number} dx - Difference in x.\n   * @param {number} dy - Difference in y.\n   * @return {number} sqrt(dx * dx + dy * dy) for grids\n   */\n  octile: function(dx, dy) {\n      var F = Math.SQRT2 - 1;\n      return (dx < dy) ? F * dx + dy : F * dy + dx;\n  },\n\n  /**\n   * Chebyshev distance.\n   * @param {number} dx - Difference in x.\n   * @param {number} dy - Difference in y.\n   * @return {number} max(dx, dy)\n   */\n  chebyshev: function(dx, dy) {\n      return Math.max(dx, dy);\n  }\n\n};\n\n},{}],6:[function(_dereq_,module,exports){\n/**\n * A node in grid. \n * This class holds some basic information about a node and custom \n * attributes may be added, depending on the algorithms' needs.\n * @constructor\n * @param {number} x - The x coordinate of the node on the grid.\n * @param {number} y - The y coordinate of the node on the grid.\n * @param {boolean} [walkable] - Whether this node is walkable.\n */\nfunction Node(x, y, walkable) {\n    /**\n     * The x coordinate of the node on the grid.\n     * @type number\n     */\n    this.x = x;\n    /**\n     * The y coordinate of the node on the grid.\n     * @type number\n     */\n    this.y = y;\n    /**\n     * Whether this node can be walked through.\n     * @type boolean\n     */\n    this.walkable = (walkable === undefined ? true : walkable);\n}\n\nmodule.exports = Node;\n\n},{}],7:[function(_dereq_,module,exports){\n/**\n * Backtrace according to the parent records and return the path.\n * (including both start and end nodes)\n * @param {Node} node End node\n * @return {Array<Array<number>>} the path\n */\nfunction backtrace(node) {\n    var path = [[node.x, node.y]];\n    while (node.parent) {\n        node = node.parent;\n        path.push([node.x, node.y]);\n    }\n    return path.reverse();\n}\nexports.backtrace = backtrace;\n\n/**\n * Backtrace from start and end node, and return the path.\n * (including both start and end nodes)\n * @param {Node}\n * @param {Node}\n */\nfunction biBacktrace(nodeA, nodeB) {\n    var pathA = backtrace(nodeA),\n        pathB = backtrace(nodeB);\n    return pathA.concat(pathB.reverse());\n}\nexports.biBacktrace = biBacktrace;\n\n/**\n * Compute the length of the path.\n * @param {Array<Array<number>>} path The path\n * @return {number} The length of the path\n */\nfunction pathLength(path) {\n    var i, sum = 0, a, b, dx, dy;\n    for (i = 1; i < path.length; ++i) {\n        a = path[i - 1];\n        b = path[i];\n        dx = a[0] - b[0];\n        dy = a[1] - b[1];\n        sum += Math.sqrt(dx * dx + dy * dy);\n    }\n    return sum;\n}\nexports.pathLength = pathLength;\n\n\n/**\n * Given the start and end coordinates, return all the coordinates lying\n * on the line formed by these coordinates, based on Bresenham's algorithm.\n * http://en.wikipedia.org/wiki/Bresenham's_line_algorithm#Simplification\n * @param {number} x0 Start x coordinate\n * @param {number} y0 Start y coordinate\n * @param {number} x1 End x coordinate\n * @param {number} y1 End y coordinate\n * @return {Array<Array<number>>} The coordinates on the line\n */\nfunction interpolate(x0, y0, x1, y1) {\n    var abs = Math.abs,\n        line = [],\n        sx, sy, dx, dy, err, e2;\n\n    dx = abs(x1 - x0);\n    dy = abs(y1 - y0);\n\n    sx = (x0 < x1) ? 1 : -1;\n    sy = (y0 < y1) ? 1 : -1;\n\n    err = dx - dy;\n\n    while (true) {\n        line.push([x0, y0]);\n\n        if (x0 === x1 && y0 === y1) {\n            break;\n        }\n        \n        e2 = 2 * err;\n        if (e2 > -dy) {\n            err = err - dy;\n            x0 = x0 + sx;\n        }\n        if (e2 < dx) {\n            err = err + dx;\n            y0 = y0 + sy;\n        }\n    }\n\n    return line;\n}\nexports.interpolate = interpolate;\n\n\n/**\n * Given a compressed path, return a new path that has all the segments\n * in it interpolated.\n * @param {Array<Array<number>>} path The path\n * @return {Array<Array<number>>} expanded path\n */\nfunction expandPath(path) {\n    var expanded = [],\n        len = path.length,\n        coord0, coord1,\n        interpolated,\n        interpolatedLen,\n        i, j;\n\n    if (len < 2) {\n        return expanded;\n    }\n\n    for (i = 0; i < len - 1; ++i) {\n        coord0 = path[i];\n        coord1 = path[i + 1];\n\n        interpolated = interpolate(coord0[0], coord0[1], coord1[0], coord1[1]);\n        interpolatedLen = interpolated.length;\n        for (j = 0; j < interpolatedLen - 1; ++j) {\n            expanded.push(interpolated[j]);\n        }\n    }\n    expanded.push(path[len - 1]);\n\n    return expanded;\n}\nexports.expandPath = expandPath;\n\n\n/**\n * Smoothen the give path.\n * The original path will not be modified; a new path will be returned.\n * @param {PF.Grid} grid\n * @param {Array<Array<number>>} path The path\n */\nfunction smoothenPath(grid, path) {\n    var len = path.length,\n        x0 = path[0][0],        // path start x\n        y0 = path[0][1],        // path start y\n        x1 = path[len - 1][0],  // path end x\n        y1 = path[len - 1][1],  // path end y\n        sx, sy,                 // current start coordinate\n        ex, ey,                 // current end coordinate\n        newPath,\n        i, j, coord, line, testCoord, blocked;\n\n    sx = x0;\n    sy = y0;\n    newPath = [[sx, sy]];\n\n    for (i = 2; i < len; ++i) {\n        coord = path[i];\n        ex = coord[0];\n        ey = coord[1];\n        line = interpolate(sx, sy, ex, ey);\n\n        blocked = false;\n        for (j = 1; j < line.length; ++j) {\n            testCoord = line[j];\n\n            if (!grid.isWalkableAt(testCoord[0], testCoord[1])) {\n                blocked = true;\n                break;\n            }\n        }\n        if (blocked) {\n            lastValidCoord = path[i - 1];\n            newPath.push(lastValidCoord);\n            sx = lastValidCoord[0];\n            sy = lastValidCoord[1];\n        }\n    }\n    newPath.push([x1, y1]);\n\n    return newPath;\n}\nexports.smoothenPath = smoothenPath;\n\n\n/**\n * Compress a path, remove redundant nodes without altering the shape\n * The original path is not modified\n * @param {Array<Array<number>>} path The path\n * @return {Array<Array<number>>} The compressed path\n */\nfunction compressPath(path) {\n\n    // nothing to compress\n    if(path.length < 3) {\n        return path;\n    }\n\n    var compressed = [],\n        sx = path[0][0], // start x\n        sy = path[0][1], // start y\n        px = path[1][0], // second point x\n        py = path[1][1], // second point y\n        dx = px - sx, // direction between the two points\n        dy = py - sy, // direction between the two points\n        lx, ly,\n        ldx, ldy,\n        sq, i;\n\n    // normalize the direction\n    sq = Math.sqrt(dx*dx + dy*dy);\n    dx /= sq;\n    dy /= sq;\n\n    // start the new path\n    compressed.push([sx,sy]);\n\n    for(i = 2; i < path.length; i++) {\n\n        // store the last point\n        lx = px;\n        ly = py;\n\n        // store the last direction\n        ldx = dx;\n        ldy = dy;\n\n        // next point\n        px = path[i][0];\n        py = path[i][1];\n\n        // next direction\n        dx = px - lx;\n        dy = py - ly;\n\n        // normalize\n        sq = Math.sqrt(dx*dx + dy*dy);\n        dx /= sq;\n        dy /= sq;\n\n        // if the direction has changed, store the point\n        if ( dx !== ldx || dy !== ldy ) {\n            compressed.push([lx,ly]);\n        }\n    }\n\n    // store the last point\n    compressed.push([px,py]);\n\n    return compressed;\n}\nexports.compressPath = compressPath;\n\n},{}],8:[function(_dereq_,module,exports){\nmodule.exports = {\n    'Heap'                      : _dereq_('heap'),\n    'Node'                      : _dereq_('./core/Node'),\n    'Grid'                      : _dereq_('./core/Grid'),\n    'Util'                      : _dereq_('./core/Util'),\n    'DiagonalMovement'          : _dereq_('./core/DiagonalMovement'),\n    'Heuristic'                 : _dereq_('./core/Heuristic'),\n    'AStarFinder'               : _dereq_('./finders/AStarFinder'),\n    'BestFirstFinder'           : _dereq_('./finders/BestFirstFinder'),\n    'BreadthFirstFinder'        : _dereq_('./finders/BreadthFirstFinder'),\n    'DijkstraFinder'            : _dereq_('./finders/DijkstraFinder'),\n    'BiAStarFinder'             : _dereq_('./finders/BiAStarFinder'),\n    'BiBestFirstFinder'         : _dereq_('./finders/BiBestFirstFinder'),\n    'BiBreadthFirstFinder'      : _dereq_('./finders/BiBreadthFirstFinder'),\n    'BiDijkstraFinder'          : _dereq_('./finders/BiDijkstraFinder'),\n    'IDAStarFinder'             : _dereq_('./finders/IDAStarFinder'),\n    'JumpPointFinder'           : _dereq_('./finders/JumpPointFinder'),\n};\n\n},{\"./core/DiagonalMovement\":3,\"./core/Grid\":4,\"./core/Heuristic\":5,\"./core/Node\":6,\"./core/Util\":7,\"./finders/AStarFinder\":9,\"./finders/BestFirstFinder\":10,\"./finders/BiAStarFinder\":11,\"./finders/BiBestFirstFinder\":12,\"./finders/BiBreadthFirstFinder\":13,\"./finders/BiDijkstraFinder\":14,\"./finders/BreadthFirstFinder\":15,\"./finders/DijkstraFinder\":16,\"./finders/IDAStarFinder\":17,\"./finders/JumpPointFinder\":22,\"heap\":1}],9:[function(_dereq_,module,exports){\nvar Heap       = _dereq_('heap');\nvar Util       = _dereq_('../core/Util');\nvar Heuristic  = _dereq_('../core/Heuristic');\nvar DiagonalMovement = _dereq_('../core/DiagonalMovement');\n\n/**\n * A* path-finder. Based upon https://github.com/bgrins/javascript-astar\n * @constructor\n * @param {Object} opt\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\n *     Deprecated, use diagonalMovement instead.\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching \n *     block corners. Deprecated, use diagonalMovement instead.\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\n * @param {function} opt.heuristic Heuristic function to estimate the distance\n *     (defaults to manhattan).\n * @param {number} opt.weight Weight to apply to the heuristic to allow for\n *     suboptimal paths, in order to speed up the search.\n */\nfunction AStarFinder(opt) {\n    opt = opt || {};\n    this.allowDiagonal = opt.allowDiagonal;\n    this.dontCrossCorners = opt.dontCrossCorners;\n    this.heuristic = opt.heuristic || Heuristic.manhattan;\n    this.weight = opt.weight || 1;\n    this.diagonalMovement = opt.diagonalMovement;\n\n    if (!this.diagonalMovement) {\n        if (!this.allowDiagonal) {\n            this.diagonalMovement = DiagonalMovement.Never;\n        } else {\n            if (this.dontCrossCorners) {\n                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;\n            } else {\n                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;\n            }\n        }\n    }\n\n    // When diagonal movement is allowed the manhattan heuristic is not\n    //admissible. It should be octile instead\n    if (this.diagonalMovement === DiagonalMovement.Never) {\n        this.heuristic = opt.heuristic || Heuristic.manhattan;\n    } else {\n        this.heuristic = opt.heuristic || Heuristic.octile;\n    }\n}\n\n/**\n * Find and return the the path.\n * @return {Array<Array<number>>} The path, including both start and\n *     end positions.\n */\nAStarFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {\n    var openList = new Heap(function(nodeA, nodeB) {\n            return nodeA.f - nodeB.f;\n        }),\n        startNode = grid.getNodeAt(startX, startY),\n        endNode = grid.getNodeAt(endX, endY),\n        heuristic = this.heuristic,\n        diagonalMovement = this.diagonalMovement,\n        weight = this.weight,\n        abs = Math.abs, SQRT2 = Math.SQRT2,\n        node, neighbors, neighbor, i, l, x, y, ng;\n\n    // set the `g` and `f` value of the start node to be 0\n    startNode.g = 0;\n    startNode.f = 0;\n\n    // push the start node into the open list\n    openList.push(startNode);\n    startNode.opened = true;\n\n    // while the open list is not empty\n    while (!openList.empty()) {\n        // pop the position of node which has the minimum `f` value.\n        node = openList.pop();\n        node.closed = true;\n\n        // if reached the end position, construct the path and return it\n        if (node === endNode) {\n            return Util.backtrace(endNode);\n        }\n\n        // get neigbours of the current node\n        neighbors = grid.getNeighbors(node, diagonalMovement);\n        for (i = 0, l = neighbors.length; i < l; ++i) {\n            neighbor = neighbors[i];\n\n            if (neighbor.closed) {\n                continue;\n            }\n\n            x = neighbor.x;\n            y = neighbor.y;\n\n            // get the distance between current node and the neighbor\n            // and calculate the next g score\n            ng = node.g + ((x - node.x === 0 || y - node.y === 0) ? 1 : SQRT2);\n\n            // check if the neighbor has not been inspected yet, or\n            // can be reached with smaller cost from the current node\n            if (!neighbor.opened || ng < neighbor.g) {\n                neighbor.g = ng;\n                neighbor.h = neighbor.h || weight * heuristic(abs(x - endX), abs(y - endY));\n                neighbor.f = neighbor.g + neighbor.h;\n                neighbor.parent = node;\n\n                if (!neighbor.opened) {\n                    openList.push(neighbor);\n                    neighbor.opened = true;\n                } else {\n                    // the neighbor can be reached with smaller cost.\n                    // Since its f value has been updated, we have to\n                    // update its position in the open list\n                    openList.updateItem(neighbor);\n                }\n            }\n        } // end for each neighbor\n    } // end while not open list empty\n\n    // fail to find the path\n    return [];\n};\n\nmodule.exports = AStarFinder;\n\n},{\"../core/DiagonalMovement\":3,\"../core/Heuristic\":5,\"../core/Util\":7,\"heap\":1}],10:[function(_dereq_,module,exports){\nvar AStarFinder = _dereq_('./AStarFinder');\n\n/**\n * Best-First-Search path-finder.\n * @constructor\n * @extends AStarFinder\n * @param {Object} opt\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\n *     Deprecated, use diagonalMovement instead.\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\n *     block corners. Deprecated, use diagonalMovement instead.\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\n * @param {function} opt.heuristic Heuristic function to estimate the distance\n *     (defaults to manhattan).\n */\nfunction BestFirstFinder(opt) {\n    AStarFinder.call(this, opt);\n\n    var orig = this.heuristic;\n    this.heuristic = function(dx, dy) {\n        return orig(dx, dy) * 1000000;\n    };\n}\n\nBestFirstFinder.prototype = new AStarFinder();\nBestFirstFinder.prototype.constructor = BestFirstFinder;\n\nmodule.exports = BestFirstFinder;\n\n},{\"./AStarFinder\":9}],11:[function(_dereq_,module,exports){\nvar Heap       = _dereq_('heap');\nvar Util       = _dereq_('../core/Util');\nvar Heuristic  = _dereq_('../core/Heuristic');\nvar DiagonalMovement = _dereq_('../core/DiagonalMovement');\n\n/**\n * A* path-finder.\n * based upon https://github.com/bgrins/javascript-astar\n * @constructor\n * @param {Object} opt\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\n *     Deprecated, use diagonalMovement instead.\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\n *     block corners. Deprecated, use diagonalMovement instead.\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\n * @param {function} opt.heuristic Heuristic function to estimate the distance\n *     (defaults to manhattan).\n * @param {number} opt.weight Weight to apply to the heuristic to allow for\n *     suboptimal paths, in order to speed up the search.\n */\nfunction BiAStarFinder(opt) {\n    opt = opt || {};\n    this.allowDiagonal = opt.allowDiagonal;\n    this.dontCrossCorners = opt.dontCrossCorners;\n    this.diagonalMovement = opt.diagonalMovement;\n    this.heuristic = opt.heuristic || Heuristic.manhattan;\n    this.weight = opt.weight || 1;\n\n    if (!this.diagonalMovement) {\n        if (!this.allowDiagonal) {\n            this.diagonalMovement = DiagonalMovement.Never;\n        } else {\n            if (this.dontCrossCorners) {\n                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;\n            } else {\n                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;\n            }\n        }\n    }\n\n    //When diagonal movement is allowed the manhattan heuristic is not admissible\n    //It should be octile instead\n    if (this.diagonalMovement === DiagonalMovement.Never) {\n        this.heuristic = opt.heuristic || Heuristic.manhattan;\n    } else {\n        this.heuristic = opt.heuristic || Heuristic.octile;\n    }\n}\n\n/**\n * Find and return the the path.\n * @return {Array<Array<number>>} The path, including both start and\n *     end positions.\n */\nBiAStarFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {\n    var cmp = function(nodeA, nodeB) {\n            return nodeA.f - nodeB.f;\n        },\n        startOpenList = new Heap(cmp),\n        endOpenList = new Heap(cmp),\n        startNode = grid.getNodeAt(startX, startY),\n        endNode = grid.getNodeAt(endX, endY),\n        heuristic = this.heuristic,\n        diagonalMovement = this.diagonalMovement,\n        weight = this.weight,\n        abs = Math.abs, SQRT2 = Math.SQRT2,\n        node, neighbors, neighbor, i, l, x, y, ng,\n        BY_START = 1, BY_END = 2;\n\n    // set the `g` and `f` value of the start node to be 0\n    // and push it into the start open list\n    startNode.g = 0;\n    startNode.f = 0;\n    startOpenList.push(startNode);\n    startNode.opened = BY_START;\n\n    // set the `g` and `f` value of the end node to be 0\n    // and push it into the open open list\n    endNode.g = 0;\n    endNode.f = 0;\n    endOpenList.push(endNode);\n    endNode.opened = BY_END;\n\n    // while both the open lists are not empty\n    while (!startOpenList.empty() && !endOpenList.empty()) {\n\n        // pop the position of start node which has the minimum `f` value.\n        node = startOpenList.pop();\n        node.closed = true;\n\n        // get neigbours of the current node\n        neighbors = grid.getNeighbors(node, diagonalMovement);\n        for (i = 0, l = neighbors.length; i < l; ++i) {\n            neighbor = neighbors[i];\n\n            if (neighbor.closed) {\n                continue;\n            }\n            if (neighbor.opened === BY_END) {\n                return Util.biBacktrace(node, neighbor);\n            }\n\n            x = neighbor.x;\n            y = neighbor.y;\n\n            // get the distance between current node and the neighbor\n            // and calculate the next g score\n            ng = node.g + ((x - node.x === 0 || y - node.y === 0) ? 1 : SQRT2);\n\n            // check if the neighbor has not been inspected yet, or\n            // can be reached with smaller cost from the current node\n            if (!neighbor.opened || ng < neighbor.g) {\n                neighbor.g = ng;\n                neighbor.h = neighbor.h ||\n                    weight * heuristic(abs(x - endX), abs(y - endY));\n                neighbor.f = neighbor.g + neighbor.h;\n                neighbor.parent = node;\n\n                if (!neighbor.opened) {\n                    startOpenList.push(neighbor);\n                    neighbor.opened = BY_START;\n                } else {\n                    // the neighbor can be reached with smaller cost.\n                    // Since its f value has been updated, we have to\n                    // update its position in the open list\n                    startOpenList.updateItem(neighbor);\n                }\n            }\n        } // end for each neighbor\n\n\n        // pop the position of end node which has the minimum `f` value.\n        node = endOpenList.pop();\n        node.closed = true;\n\n        // get neigbours of the current node\n        neighbors = grid.getNeighbors(node, diagonalMovement);\n        for (i = 0, l = neighbors.length; i < l; ++i) {\n            neighbor = neighbors[i];\n\n            if (neighbor.closed) {\n                continue;\n            }\n            if (neighbor.opened === BY_START) {\n                return Util.biBacktrace(neighbor, node);\n            }\n\n            x = neighbor.x;\n            y = neighbor.y;\n\n            // get the distance between current node and the neighbor\n            // and calculate the next g score\n            ng = node.g + ((x - node.x === 0 || y - node.y === 0) ? 1 : SQRT2);\n\n            // check if the neighbor has not been inspected yet, or\n            // can be reached with smaller cost from the current node\n            if (!neighbor.opened || ng < neighbor.g) {\n                neighbor.g = ng;\n                neighbor.h = neighbor.h ||\n                    weight * heuristic(abs(x - startX), abs(y - startY));\n                neighbor.f = neighbor.g + neighbor.h;\n                neighbor.parent = node;\n\n                if (!neighbor.opened) {\n                    endOpenList.push(neighbor);\n                    neighbor.opened = BY_END;\n                } else {\n                    // the neighbor can be reached with smaller cost.\n                    // Since its f value has been updated, we have to\n                    // update its position in the open list\n                    endOpenList.updateItem(neighbor);\n                }\n            }\n        } // end for each neighbor\n    } // end while not open list empty\n\n    // fail to find the path\n    return [];\n};\n\nmodule.exports = BiAStarFinder;\n\n},{\"../core/DiagonalMovement\":3,\"../core/Heuristic\":5,\"../core/Util\":7,\"heap\":1}],12:[function(_dereq_,module,exports){\nvar BiAStarFinder = _dereq_('./BiAStarFinder');\n\n/**\n * Bi-direcitional Best-First-Search path-finder.\n * @constructor\n * @extends BiAStarFinder\n * @param {Object} opt\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\n *     Deprecated, use diagonalMovement instead.\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\n *     block corners. Deprecated, use diagonalMovement instead.\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\n * @param {function} opt.heuristic Heuristic function to estimate the distance\n *     (defaults to manhattan).\n */\nfunction BiBestFirstFinder(opt) {\n    BiAStarFinder.call(this, opt);\n\n    var orig = this.heuristic;\n    this.heuristic = function(dx, dy) {\n        return orig(dx, dy) * 1000000;\n    };\n}\n\nBiBestFirstFinder.prototype = new BiAStarFinder();\nBiBestFirstFinder.prototype.constructor = BiBestFirstFinder;\n\nmodule.exports = BiBestFirstFinder;\n\n},{\"./BiAStarFinder\":11}],13:[function(_dereq_,module,exports){\nvar Util = _dereq_('../core/Util');\nvar DiagonalMovement = _dereq_('../core/DiagonalMovement');\n\n/**\n * Bi-directional Breadth-First-Search path finder.\n * @constructor\n * @param {object} opt\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\n *     Deprecated, use diagonalMovement instead.\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\n *     block corners. Deprecated, use diagonalMovement instead.\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\n */\nfunction BiBreadthFirstFinder(opt) {\n    opt = opt || {};\n    this.allowDiagonal = opt.allowDiagonal;\n    this.dontCrossCorners = opt.dontCrossCorners;\n    this.diagonalMovement = opt.diagonalMovement;\n\n    if (!this.diagonalMovement) {\n        if (!this.allowDiagonal) {\n            this.diagonalMovement = DiagonalMovement.Never;\n        } else {\n            if (this.dontCrossCorners) {\n                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;\n            } else {\n                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;\n            }\n        }\n    }\n}\n\n\n/**\n * Find and return the the path.\n * @return {Array<Array<number>>} The path, including both start and\n *     end positions.\n */\nBiBreadthFirstFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {\n    var startNode = grid.getNodeAt(startX, startY),\n        endNode = grid.getNodeAt(endX, endY),\n        startOpenList = [], endOpenList = [],\n        neighbors, neighbor, node,\n        diagonalMovement = this.diagonalMovement,\n        BY_START = 0, BY_END = 1,\n        i, l;\n\n    // push the start and end nodes into the queues\n    startOpenList.push(startNode);\n    startNode.opened = true;\n    startNode.by = BY_START;\n\n    endOpenList.push(endNode);\n    endNode.opened = true;\n    endNode.by = BY_END;\n\n    // while both the queues are not empty\n    while (startOpenList.length && endOpenList.length) {\n\n        // expand start open list\n\n        node = startOpenList.shift();\n        node.closed = true;\n\n        neighbors = grid.getNeighbors(node, diagonalMovement);\n        for (i = 0, l = neighbors.length; i < l; ++i) {\n            neighbor = neighbors[i];\n\n            if (neighbor.closed) {\n                continue;\n            }\n            if (neighbor.opened) {\n                // if this node has been inspected by the reversed search,\n                // then a path is found.\n                if (neighbor.by === BY_END) {\n                    return Util.biBacktrace(node, neighbor);\n                }\n                continue;\n            }\n            startOpenList.push(neighbor);\n            neighbor.parent = node;\n            neighbor.opened = true;\n            neighbor.by = BY_START;\n        }\n\n        // expand end open list\n\n        node = endOpenList.shift();\n        node.closed = true;\n\n        neighbors = grid.getNeighbors(node, diagonalMovement);\n        for (i = 0, l = neighbors.length; i < l; ++i) {\n            neighbor = neighbors[i];\n\n            if (neighbor.closed) {\n                continue;\n            }\n            if (neighbor.opened) {\n                if (neighbor.by === BY_START) {\n                    return Util.biBacktrace(neighbor, node);\n                }\n                continue;\n            }\n            endOpenList.push(neighbor);\n            neighbor.parent = node;\n            neighbor.opened = true;\n            neighbor.by = BY_END;\n        }\n    }\n\n    // fail to find the path\n    return [];\n};\n\nmodule.exports = BiBreadthFirstFinder;\n\n},{\"../core/DiagonalMovement\":3,\"../core/Util\":7}],14:[function(_dereq_,module,exports){\nvar BiAStarFinder = _dereq_('./BiAStarFinder');\n\n/**\n * Bi-directional Dijkstra path-finder.\n * @constructor\n * @extends BiAStarFinder\n * @param {Object} opt\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\n *     Deprecated, use diagonalMovement instead.\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\n *     block corners. Deprecated, use diagonalMovement instead.\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\n */\nfunction BiDijkstraFinder(opt) {\n    BiAStarFinder.call(this, opt);\n    this.heuristic = function(dx, dy) {\n        return 0;\n    };\n}\n\nBiDijkstraFinder.prototype = new BiAStarFinder();\nBiDijkstraFinder.prototype.constructor = BiDijkstraFinder;\n\nmodule.exports = BiDijkstraFinder;\n\n},{\"./BiAStarFinder\":11}],15:[function(_dereq_,module,exports){\nvar Util = _dereq_('../core/Util');\nvar DiagonalMovement = _dereq_('../core/DiagonalMovement');\n\n/**\n * Breadth-First-Search path finder.\n * @constructor\n * @param {Object} opt\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\n *     Deprecated, use diagonalMovement instead.\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\n *     block corners. Deprecated, use diagonalMovement instead.\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\n */\nfunction BreadthFirstFinder(opt) {\n    opt = opt || {};\n    this.allowDiagonal = opt.allowDiagonal;\n    this.dontCrossCorners = opt.dontCrossCorners;\n    this.diagonalMovement = opt.diagonalMovement;\n\n    if (!this.diagonalMovement) {\n        if (!this.allowDiagonal) {\n            this.diagonalMovement = DiagonalMovement.Never;\n        } else {\n            if (this.dontCrossCorners) {\n                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;\n            } else {\n                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;\n            }\n        }\n    }\n}\n\n/**\n * Find and return the the path.\n * @return {Array<Array<number>>} The path, including both start and\n *     end positions.\n */\nBreadthFirstFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {\n    var openList = [],\n        diagonalMovement = this.diagonalMovement,\n        startNode = grid.getNodeAt(startX, startY),\n        endNode = grid.getNodeAt(endX, endY),\n        neighbors, neighbor, node, i, l;\n\n    // push the start pos into the queue\n    openList.push(startNode);\n    startNode.opened = true;\n\n    // while the queue is not empty\n    while (openList.length) {\n        // take the front node from the queue\n        node = openList.shift();\n        node.closed = true;\n\n        // reached the end position\n        if (node === endNode) {\n            return Util.backtrace(endNode);\n        }\n\n        neighbors = grid.getNeighbors(node, diagonalMovement);\n        for (i = 0, l = neighbors.length; i < l; ++i) {\n            neighbor = neighbors[i];\n\n            // skip this neighbor if it has been inspected before\n            if (neighbor.closed || neighbor.opened) {\n                continue;\n            }\n\n            openList.push(neighbor);\n            neighbor.opened = true;\n            neighbor.parent = node;\n        }\n    }\n    \n    // fail to find the path\n    return [];\n};\n\nmodule.exports = BreadthFirstFinder;\n\n},{\"../core/DiagonalMovement\":3,\"../core/Util\":7}],16:[function(_dereq_,module,exports){\nvar AStarFinder = _dereq_('./AStarFinder');\n\n/**\n * Dijkstra path-finder.\n * @constructor\n * @extends AStarFinder\n * @param {Object} opt\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\n *     Deprecated, use diagonalMovement instead.\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\n *     block corners. Deprecated, use diagonalMovement instead.\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\n */\nfunction DijkstraFinder(opt) {\n    AStarFinder.call(this, opt);\n    this.heuristic = function(dx, dy) {\n        return 0;\n    };\n}\n\nDijkstraFinder.prototype = new AStarFinder();\nDijkstraFinder.prototype.constructor = DijkstraFinder;\n\nmodule.exports = DijkstraFinder;\n\n},{\"./AStarFinder\":9}],17:[function(_dereq_,module,exports){\nvar Util       = _dereq_('../core/Util');\nvar Heuristic  = _dereq_('../core/Heuristic');\nvar Node       = _dereq_('../core/Node');\nvar DiagonalMovement = _dereq_('../core/DiagonalMovement');\n\n/**\n * Iterative Deeping A Star (IDA*) path-finder.\n *\n * Recursion based on:\n *   http://www.apl.jhu.edu/~hall/AI-Programming/IDA-Star.html\n *\n * Path retracing based on:\n *  V. Nageshwara Rao, Vipin Kumar and K. Ramesh\n *  \"A Parallel Implementation of Iterative-Deeping-A*\", January 1987.\n *  ftp://ftp.cs.utexas.edu/.snapshot/hourly.1/pub/AI-Lab/tech-reports/UT-AI-TR-87-46.pdf\n *\n * @author Gerard Meier (www.gerardmeier.com)\n *\n * @constructor\n * @param {Object} opt\n * @param {boolean} opt.allowDiagonal Whether diagonal movement is allowed.\n *     Deprecated, use diagonalMovement instead.\n * @param {boolean} opt.dontCrossCorners Disallow diagonal movement touching\n *     block corners. Deprecated, use diagonalMovement instead.\n * @param {DiagonalMovement} opt.diagonalMovement Allowed diagonal movement.\n * @param {function} opt.heuristic Heuristic function to estimate the distance\n *     (defaults to manhattan).\n * @param {number} opt.weight Weight to apply to the heuristic to allow for\n *     suboptimal paths, in order to speed up the search.\n * @param {boolean} opt.trackRecursion Whether to track recursion for\n *     statistical purposes.\n * @param {number} opt.timeLimit Maximum execution time. Use <= 0 for infinite.\n */\nfunction IDAStarFinder(opt) {\n    opt = opt || {};\n    this.allowDiagonal = opt.allowDiagonal;\n    this.dontCrossCorners = opt.dontCrossCorners;\n    this.diagonalMovement = opt.diagonalMovement;\n    this.heuristic = opt.heuristic || Heuristic.manhattan;\n    this.weight = opt.weight || 1;\n    this.trackRecursion = opt.trackRecursion || false;\n    this.timeLimit = opt.timeLimit || Infinity; // Default: no time limit.\n\n    if (!this.diagonalMovement) {\n        if (!this.allowDiagonal) {\n            this.diagonalMovement = DiagonalMovement.Never;\n        } else {\n            if (this.dontCrossCorners) {\n                this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;\n            } else {\n                this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;\n            }\n        }\n    }\n\n    // When diagonal movement is allowed the manhattan heuristic is not\n    // admissible, it should be octile instead\n    if (this.diagonalMovement === DiagonalMovement.Never) {\n        this.heuristic = opt.heuristic || Heuristic.manhattan;\n    } else {\n        this.heuristic = opt.heuristic || Heuristic.octile;\n    }\n}\n\n/**\n * Find and return the the path. When an empty array is returned, either\n * no path is possible, or the maximum execution time is reached.\n *\n * @return {Array<Array<number>>} The path, including both start and\n *     end positions.\n */\nIDAStarFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {\n    // Used for statistics:\n    var nodesVisited = 0;\n\n    // Execution time limitation:\n    var startTime = new Date().getTime();\n\n    // Heuristic helper:\n    var h = function(a, b) {\n        return this.heuristic(Math.abs(b.x - a.x), Math.abs(b.y - a.y));\n    }.bind(this);\n\n    // Step cost from a to b:\n    var cost = function(a, b) {\n        return (a.x === b.x || a.y === b.y) ? 1 : Math.SQRT2;\n    };\n\n    /**\n     * IDA* search implementation.\n     *\n     * @param {Node} The node currently expanding from.\n     * @param {number} Cost to reach the given node.\n     * @param {number} Maximum search depth (cut-off value).\n     * @param {Array<Array<number>>} The found route.\n     * @param {number} Recursion depth.\n     *\n     * @return {Object} either a number with the new optimal cut-off depth,\n     * or a valid node instance, in which case a path was found.\n     */\n    var search = function(node, g, cutoff, route, depth) {\n        nodesVisited++;\n\n        // Enforce timelimit:\n        if (this.timeLimit > 0 &&\n            new Date().getTime() - startTime > this.timeLimit * 1000) {\n            // Enforced as \"path-not-found\".\n            return Infinity;\n        }\n\n        var f = g + h(node, end) * this.weight;\n\n        // We've searched too deep for this iteration.\n        if (f > cutoff) {\n            return f;\n        }\n\n        if (node == end) {\n            route[depth] = [node.x, node.y];\n            return node;\n        }\n\n        var min, t, k, neighbour;\n\n        var neighbours = grid.getNeighbors(node, this.diagonalMovement);\n\n        // Sort the neighbours, gives nicer paths. But, this deviates\n        // from the original algorithm - so I left it out.\n        //neighbours.sort(function(a, b){\n        //    return h(a, end) - h(b, end);\n        //});\n\n        \n        /*jshint -W084 *///Disable warning: Expected a conditional expression and instead saw an assignment\n        for (k = 0, min = Infinity; neighbour = neighbours[k]; ++k) {\n        /*jshint +W084 *///Enable warning: Expected a conditional expression and instead saw an assignment\n            if (this.trackRecursion) {\n                // Retain a copy for visualisation. Due to recursion, this\n                // node may be part of other paths too.\n                neighbour.retainCount = neighbour.retainCount + 1 || 1;\n\n                if(neighbour.tested !== true) {\n                    neighbour.tested = true;\n                }\n            }\n\n            t = search(neighbour, g + cost(node, neighbour), cutoff, route, depth + 1);\n\n            if (t instanceof Node) {\n                route[depth] = [node.x, node.y];\n\n                // For a typical A* linked list, this would work:\n                // neighbour.parent = node;\n                return t;\n            }\n\n            // Decrement count, then determine whether it's actually closed.\n            if (this.trackRecursion && (--neighbour.retainCount) === 0) {\n                neighbour.tested = false;\n            }\n\n            if (t < min) {\n                min = t;\n            }\n        }\n\n        return min;\n\n    }.bind(this);\n\n    // Node instance lookups:\n    var start = grid.getNodeAt(startX, startY);\n    var end   = grid.getNodeAt(endX, endY);\n\n    // Initial search depth, given the typical heuristic contraints,\n    // there should be no cheaper route possible.\n    var cutOff = h(start, end);\n\n    var j, route, t;\n\n    // With an overflow protection.\n    for (j = 0; true; ++j) {\n\n        route = [];\n\n        // Search till cut-off depth:\n        t = search(start, 0, cutOff, route, 0);\n\n        // Route not possible, or not found in time limit.\n        if (t === Infinity) {\n            return [];\n        }\n\n        // If t is a node, it's also the end node. Route is now\n        // populated with a valid path to the end node.\n        if (t instanceof Node) {\n            return route;\n        }\n\n        // Try again, this time with a deeper cut-off. The t score\n        // is the closest we got to the end node.\n        cutOff = t;\n    }\n\n    // This _should_ never to be reached.\n    return [];\n};\n\nmodule.exports = IDAStarFinder;\n\n},{\"../core/DiagonalMovement\":3,\"../core/Heuristic\":5,\"../core/Node\":6,\"../core/Util\":7}],18:[function(_dereq_,module,exports){\n/**\n * @author imor / https://github.com/imor\n */\nvar JumpPointFinderBase = _dereq_('./JumpPointFinderBase');\nvar DiagonalMovement = _dereq_('../core/DiagonalMovement');\n\n/**\n * Path finder using the Jump Point Search algorithm which always moves\n * diagonally irrespective of the number of obstacles.\n */\nfunction JPFAlwaysMoveDiagonally(opt) {\n    JumpPointFinderBase.call(this, opt);\n}\n\nJPFAlwaysMoveDiagonally.prototype = new JumpPointFinderBase();\nJPFAlwaysMoveDiagonally.prototype.constructor = JPFAlwaysMoveDiagonally;\n\n/**\n * Search recursively in the direction (parent -> child), stopping only when a\n * jump point is found.\n * @protected\n * @return {Array<Array<number>>} The x, y coordinate of the jump point\n *     found, or null if not found\n */\nJPFAlwaysMoveDiagonally.prototype._jump = function(x, y, px, py) {\n    var grid = this.grid,\n        dx = x - px, dy = y - py;\n\n    if (!grid.isWalkableAt(x, y)) {\n        return null;\n    }\n\n    if(this.trackJumpRecursion === true) {\n        grid.getNodeAt(x, y).tested = true;\n    }\n\n    if (grid.getNodeAt(x, y) === this.endNode) {\n        return [x, y];\n    }\n\n    // check for forced neighbors\n    // along the diagonal\n    if (dx !== 0 && dy !== 0) {\n        if ((grid.isWalkableAt(x - dx, y + dy) && !grid.isWalkableAt(x - dx, y)) ||\n            (grid.isWalkableAt(x + dx, y - dy) && !grid.isWalkableAt(x, y - dy))) {\n            return [x, y];\n        }\n        // when moving diagonally, must check for vertical/horizontal jump points\n        if (this._jump(x + dx, y, x, y) || this._jump(x, y + dy, x, y)) {\n            return [x, y];\n        }\n    }\n    // horizontally/vertically\n    else {\n        if( dx !== 0 ) { // moving along x\n            if((grid.isWalkableAt(x + dx, y + 1) && !grid.isWalkableAt(x, y + 1)) ||\n               (grid.isWalkableAt(x + dx, y - 1) && !grid.isWalkableAt(x, y - 1))) {\n                return [x, y];\n            }\n        }\n        else {\n            if((grid.isWalkableAt(x + 1, y + dy) && !grid.isWalkableAt(x + 1, y)) ||\n               (grid.isWalkableAt(x - 1, y + dy) && !grid.isWalkableAt(x - 1, y))) {\n                return [x, y];\n            }\n        }\n    }\n\n    return this._jump(x + dx, y + dy, x, y);\n};\n\n/**\n * Find the neighbors for the given node. If the node has a parent,\n * prune the neighbors based on the jump point search algorithm, otherwise\n * return all available neighbors.\n * @return {Array<Array<number>>} The neighbors found.\n */\nJPFAlwaysMoveDiagonally.prototype._findNeighbors = function(node) {\n    var parent = node.parent,\n        x = node.x, y = node.y,\n        grid = this.grid,\n        px, py, nx, ny, dx, dy,\n        neighbors = [], neighborNodes, neighborNode, i, l;\n\n    // directed pruning: can ignore most neighbors, unless forced.\n    if (parent) {\n        px = parent.x;\n        py = parent.y;\n        // get the normalized direction of travel\n        dx = (x - px) / Math.max(Math.abs(x - px), 1);\n        dy = (y - py) / Math.max(Math.abs(y - py), 1);\n\n        // search diagonally\n        if (dx !== 0 && dy !== 0) {\n            if (grid.isWalkableAt(x, y + dy)) {\n                neighbors.push([x, y + dy]);\n            }\n            if (grid.isWalkableAt(x + dx, y)) {\n                neighbors.push([x + dx, y]);\n            }\n            if (grid.isWalkableAt(x + dx, y + dy)) {\n                neighbors.push([x + dx, y + dy]);\n            }\n            if (!grid.isWalkableAt(x - dx, y)) {\n                neighbors.push([x - dx, y + dy]);\n            }\n            if (!grid.isWalkableAt(x, y - dy)) {\n                neighbors.push([x + dx, y - dy]);\n            }\n        }\n        // search horizontally/vertically\n        else {\n            if(dx === 0) {\n                if (grid.isWalkableAt(x, y + dy)) {\n                    neighbors.push([x, y + dy]);\n                }\n                if (!grid.isWalkableAt(x + 1, y)) {\n                    neighbors.push([x + 1, y + dy]);\n                }\n                if (!grid.isWalkableAt(x - 1, y)) {\n                    neighbors.push([x - 1, y + dy]);\n                }\n            }\n            else {\n                if (grid.isWalkableAt(x + dx, y)) {\n                    neighbors.push([x + dx, y]);\n                }\n                if (!grid.isWalkableAt(x, y + 1)) {\n                    neighbors.push([x + dx, y + 1]);\n                }\n                if (!grid.isWalkableAt(x, y - 1)) {\n                    neighbors.push([x + dx, y - 1]);\n                }\n            }\n        }\n    }\n    // return all neighbors\n    else {\n        neighborNodes = grid.getNeighbors(node, DiagonalMovement.Always);\n        for (i = 0, l = neighborNodes.length; i < l; ++i) {\n            neighborNode = neighborNodes[i];\n            neighbors.push([neighborNode.x, neighborNode.y]);\n        }\n    }\n\n    return neighbors;\n};\n\nmodule.exports = JPFAlwaysMoveDiagonally;\n\n},{\"../core/DiagonalMovement\":3,\"./JumpPointFinderBase\":23}],19:[function(_dereq_,module,exports){\n/**\n * @author imor / https://github.com/imor\n */\nvar JumpPointFinderBase = _dereq_('./JumpPointFinderBase');\nvar DiagonalMovement = _dereq_('../core/DiagonalMovement');\n\n/**\n * Path finder using the Jump Point Search algorithm which moves\n * diagonally only when there is at most one obstacle.\n */\nfunction JPFMoveDiagonallyIfAtMostOneObstacle(opt) {\n    JumpPointFinderBase.call(this, opt);\n}\n\nJPFMoveDiagonallyIfAtMostOneObstacle.prototype = new JumpPointFinderBase();\nJPFMoveDiagonallyIfAtMostOneObstacle.prototype.constructor = JPFMoveDiagonallyIfAtMostOneObstacle;\n\n/**\n * Search recursively in the direction (parent -> child), stopping only when a\n * jump point is found.\n * @protected\n * @return {Array<Array<number>>} The x, y coordinate of the jump point\n *     found, or null if not found\n */\nJPFMoveDiagonallyIfAtMostOneObstacle.prototype._jump = function(x, y, px, py) {\n    var grid = this.grid,\n        dx = x - px, dy = y - py;\n\n    if (!grid.isWalkableAt(x, y)) {\n        return null;\n    }\n\n    if(this.trackJumpRecursion === true) {\n        grid.getNodeAt(x, y).tested = true;\n    }\n\n    if (grid.getNodeAt(x, y) === this.endNode) {\n        return [x, y];\n    }\n\n    // check for forced neighbors\n    // along the diagonal\n    if (dx !== 0 && dy !== 0) {\n        if ((grid.isWalkableAt(x - dx, y + dy) && !grid.isWalkableAt(x - dx, y)) ||\n            (grid.isWalkableAt(x + dx, y - dy) && !grid.isWalkableAt(x, y - dy))) {\n            return [x, y];\n        }\n        // when moving diagonally, must check for vertical/horizontal jump points\n        if (this._jump(x + dx, y, x, y) || this._jump(x, y + dy, x, y)) {\n            return [x, y];\n        }\n    }\n    // horizontally/vertically\n    else {\n        if( dx !== 0 ) { // moving along x\n            if((grid.isWalkableAt(x + dx, y + 1) && !grid.isWalkableAt(x, y + 1)) ||\n               (grid.isWalkableAt(x + dx, y - 1) && !grid.isWalkableAt(x, y - 1))) {\n                return [x, y];\n            }\n        }\n        else {\n            if((grid.isWalkableAt(x + 1, y + dy) && !grid.isWalkableAt(x + 1, y)) ||\n               (grid.isWalkableAt(x - 1, y + dy) && !grid.isWalkableAt(x - 1, y))) {\n                return [x, y];\n            }\n        }\n    }\n\n    // moving diagonally, must make sure one of the vertical/horizontal\n    // neighbors is open to allow the path\n    if (grid.isWalkableAt(x + dx, y) || grid.isWalkableAt(x, y + dy)) {\n        return this._jump(x + dx, y + dy, x, y);\n    } else {\n        return null;\n    }\n};\n\n/**\n * Find the neighbors for the given node. If the node has a parent,\n * prune the neighbors based on the jump point search algorithm, otherwise\n * return all available neighbors.\n * @return {Array<Array<number>>} The neighbors found.\n */\nJPFMoveDiagonallyIfAtMostOneObstacle.prototype._findNeighbors = function(node) {\n    var parent = node.parent,\n        x = node.x, y = node.y,\n        grid = this.grid,\n        px, py, nx, ny, dx, dy,\n        neighbors = [], neighborNodes, neighborNode, i, l;\n\n    // directed pruning: can ignore most neighbors, unless forced.\n    if (parent) {\n        px = parent.x;\n        py = parent.y;\n        // get the normalized direction of travel\n        dx = (x - px) / Math.max(Math.abs(x - px), 1);\n        dy = (y - py) / Math.max(Math.abs(y - py), 1);\n\n        // search diagonally\n        if (dx !== 0 && dy !== 0) {\n            if (grid.isWalkableAt(x, y + dy)) {\n                neighbors.push([x, y + dy]);\n            }\n            if (grid.isWalkableAt(x + dx, y)) {\n                neighbors.push([x + dx, y]);\n            }\n            if (grid.isWalkableAt(x, y + dy) || grid.isWalkableAt(x + dx, y)) {\n                neighbors.push([x + dx, y + dy]);\n            }\n            if (!grid.isWalkableAt(x - dx, y) && grid.isWalkableAt(x, y + dy)) {\n                neighbors.push([x - dx, y + dy]);\n            }\n            if (!grid.isWalkableAt(x, y - dy) && grid.isWalkableAt(x + dx, y)) {\n                neighbors.push([x + dx, y - dy]);\n            }\n        }\n        // search horizontally/vertically\n        else {\n            if(dx === 0) {\n                if (grid.isWalkableAt(x, y + dy)) {\n                    neighbors.push([x, y + dy]);\n                    if (!grid.isWalkableAt(x + 1, y)) {\n                        neighbors.push([x + 1, y + dy]);\n                    }\n                    if (!grid.isWalkableAt(x - 1, y)) {\n                        neighbors.push([x - 1, y + dy]);\n                    }\n                }\n            }\n            else {\n                if (grid.isWalkableAt(x + dx, y)) {\n                    neighbors.push([x + dx, y]);\n                    if (!grid.isWalkableAt(x, y + 1)) {\n                        neighbors.push([x + dx, y + 1]);\n                    }\n                    if (!grid.isWalkableAt(x, y - 1)) {\n                        neighbors.push([x + dx, y - 1]);\n                    }\n                }\n            }\n        }\n    }\n    // return all neighbors\n    else {\n        neighborNodes = grid.getNeighbors(node, DiagonalMovement.IfAtMostOneObstacle);\n        for (i = 0, l = neighborNodes.length; i < l; ++i) {\n            neighborNode = neighborNodes[i];\n            neighbors.push([neighborNode.x, neighborNode.y]);\n        }\n    }\n\n    return neighbors;\n};\n\nmodule.exports = JPFMoveDiagonallyIfAtMostOneObstacle;\n\n},{\"../core/DiagonalMovement\":3,\"./JumpPointFinderBase\":23}],20:[function(_dereq_,module,exports){\n/**\n * @author imor / https://github.com/imor\n */\nvar JumpPointFinderBase = _dereq_('./JumpPointFinderBase');\nvar DiagonalMovement = _dereq_('../core/DiagonalMovement');\n\n/**\n * Path finder using the Jump Point Search algorithm which moves\n * diagonally only when there are no obstacles.\n */\nfunction JPFMoveDiagonallyIfNoObstacles(opt) {\n    JumpPointFinderBase.call(this, opt);\n}\n\nJPFMoveDiagonallyIfNoObstacles.prototype = new JumpPointFinderBase();\nJPFMoveDiagonallyIfNoObstacles.prototype.constructor = JPFMoveDiagonallyIfNoObstacles;\n\n/**\n * Search recursively in the direction (parent -> child), stopping only when a\n * jump point is found.\n * @protected\n * @return {Array<Array<number>>} The x, y coordinate of the jump point\n *     found, or null if not found\n */\nJPFMoveDiagonallyIfNoObstacles.prototype._jump = function(x, y, px, py) {\n    var grid = this.grid,\n        dx = x - px, dy = y - py;\n\n    if (!grid.isWalkableAt(x, y)) {\n        return null;\n    }\n\n    if(this.trackJumpRecursion === true) {\n        grid.getNodeAt(x, y).tested = true;\n    }\n\n    if (grid.getNodeAt(x, y) === this.endNode) {\n        return [x, y];\n    }\n\n    // check for forced neighbors\n    // along the diagonal\n    if (dx !== 0 && dy !== 0) {\n        // if ((grid.isWalkableAt(x - dx, y + dy) && !grid.isWalkableAt(x - dx, y)) ||\n            // (grid.isWalkableAt(x + dx, y - dy) && !grid.isWalkableAt(x, y - dy))) {\n            // return [x, y];\n        // }\n        // when moving diagonally, must check for vertical/horizontal jump points\n        if (this._jump(x + dx, y, x, y) || this._jump(x, y + dy, x, y)) {\n            return [x, y];\n        }\n    }\n    // horizontally/vertically\n    else {\n        if (dx !== 0) {\n            if ((grid.isWalkableAt(x, y - 1) && !grid.isWalkableAt(x - dx, y - 1)) ||\n                (grid.isWalkableAt(x, y + 1) && !grid.isWalkableAt(x - dx, y + 1))) {\n                return [x, y];\n            }\n        }\n        else if (dy !== 0) {\n            if ((grid.isWalkableAt(x - 1, y) && !grid.isWalkableAt(x - 1, y - dy)) ||\n                (grid.isWalkableAt(x + 1, y) && !grid.isWalkableAt(x + 1, y - dy))) {\n                return [x, y];\n            }\n            // When moving vertically, must check for horizontal jump points\n            // if (this._jump(x + 1, y, x, y) || this._jump(x - 1, y, x, y)) {\n                // return [x, y];\n            // }\n        }\n    }\n\n    // moving diagonally, must make sure one of the vertical/horizontal\n    // neighbors is open to allow the path\n    if (grid.isWalkableAt(x + dx, y) && grid.isWalkableAt(x, y + dy)) {\n        return this._jump(x + dx, y + dy, x, y);\n    } else {\n        return null;\n    }\n};\n\n/**\n * Find the neighbors for the given node. If the node has a parent,\n * prune the neighbors based on the jump point search algorithm, otherwise\n * return all available neighbors.\n * @return {Array<Array<number>>} The neighbors found.\n */\nJPFMoveDiagonallyIfNoObstacles.prototype._findNeighbors = function(node) {\n    var parent = node.parent,\n        x = node.x, y = node.y,\n        grid = this.grid,\n        px, py, nx, ny, dx, dy,\n        neighbors = [], neighborNodes, neighborNode, i, l;\n\n    // directed pruning: can ignore most neighbors, unless forced.\n    if (parent) {\n        px = parent.x;\n        py = parent.y;\n        // get the normalized direction of travel\n        dx = (x - px) / Math.max(Math.abs(x - px), 1);\n        dy = (y - py) / Math.max(Math.abs(y - py), 1);\n\n        // search diagonally\n        if (dx !== 0 && dy !== 0) {\n            if (grid.isWalkableAt(x, y + dy)) {\n                neighbors.push([x, y + dy]);\n            }\n            if (grid.isWalkableAt(x + dx, y)) {\n                neighbors.push([x + dx, y]);\n            }\n            if (grid.isWalkableAt(x, y + dy) && grid.isWalkableAt(x + dx, y)) {\n                neighbors.push([x + dx, y + dy]);\n            }\n        }\n        // search horizontally/vertically\n        else {\n            var isNextWalkable;\n            if (dx !== 0) {\n                isNextWalkable = grid.isWalkableAt(x + dx, y);\n                var isTopWalkable = grid.isWalkableAt(x, y + 1);\n                var isBottomWalkable = grid.isWalkableAt(x, y - 1);\n\n                if (isNextWalkable) {\n                    neighbors.push([x + dx, y]);\n                    if (isTopWalkable) {\n                        neighbors.push([x + dx, y + 1]);\n                    }\n                    if (isBottomWalkable) {\n                        neighbors.push([x + dx, y - 1]);\n                    }\n                }\n                if (isTopWalkable) {\n                    neighbors.push([x, y + 1]);\n                }\n                if (isBottomWalkable) {\n                    neighbors.push([x, y - 1]);\n                }\n            }\n            else if (dy !== 0) {\n                isNextWalkable = grid.isWalkableAt(x, y + dy);\n                var isRightWalkable = grid.isWalkableAt(x + 1, y);\n                var isLeftWalkable = grid.isWalkableAt(x - 1, y);\n\n                if (isNextWalkable) {\n                    neighbors.push([x, y + dy]);\n                    if (isRightWalkable) {\n                        neighbors.push([x + 1, y + dy]);\n                    }\n                    if (isLeftWalkable) {\n                        neighbors.push([x - 1, y + dy]);\n                    }\n                }\n                if (isRightWalkable) {\n                    neighbors.push([x + 1, y]);\n                }\n                if (isLeftWalkable) {\n                    neighbors.push([x - 1, y]);\n                }\n            }\n        }\n    }\n    // return all neighbors\n    else {\n        neighborNodes = grid.getNeighbors(node, DiagonalMovement.OnlyWhenNoObstacles);\n        for (i = 0, l = neighborNodes.length; i < l; ++i) {\n            neighborNode = neighborNodes[i];\n            neighbors.push([neighborNode.x, neighborNode.y]);\n        }\n    }\n\n    return neighbors;\n};\n\nmodule.exports = JPFMoveDiagonallyIfNoObstacles;\n\n},{\"../core/DiagonalMovement\":3,\"./JumpPointFinderBase\":23}],21:[function(_dereq_,module,exports){\n/**\n * @author imor / https://github.com/imor\n */\nvar JumpPointFinderBase = _dereq_('./JumpPointFinderBase');\nvar DiagonalMovement = _dereq_('../core/DiagonalMovement');\n\n/**\n * Path finder using the Jump Point Search algorithm allowing only horizontal\n * or vertical movements.\n */\nfunction JPFNeverMoveDiagonally(opt) {\n    JumpPointFinderBase.call(this, opt);\n}\n\nJPFNeverMoveDiagonally.prototype = new JumpPointFinderBase();\nJPFNeverMoveDiagonally.prototype.constructor = JPFNeverMoveDiagonally;\n\n/**\n * Search recursively in the direction (parent -> child), stopping only when a\n * jump point is found.\n * @protected\n * @return {Array<Array<number>>} The x, y coordinate of the jump point\n *     found, or null if not found\n */\nJPFNeverMoveDiagonally.prototype._jump = function(x, y, px, py) {\n    var grid = this.grid,\n        dx = x - px, dy = y - py;\n\n    if (!grid.isWalkableAt(x, y)) {\n        return null;\n    }\n\n    if(this.trackJumpRecursion === true) {\n        grid.getNodeAt(x, y).tested = true;\n    }\n\n    if (grid.getNodeAt(x, y) === this.endNode) {\n        return [x, y];\n    }\n\n    if (dx !== 0) {\n        if ((grid.isWalkableAt(x, y - 1) && !grid.isWalkableAt(x - dx, y - 1)) ||\n            (grid.isWalkableAt(x, y + 1) && !grid.isWalkableAt(x - dx, y + 1))) {\n            return [x, y];\n        }\n    }\n    else if (dy !== 0) {\n        if ((grid.isWalkableAt(x - 1, y) && !grid.isWalkableAt(x - 1, y - dy)) ||\n            (grid.isWalkableAt(x + 1, y) && !grid.isWalkableAt(x + 1, y - dy))) {\n            return [x, y];\n        }\n        //When moving vertically, must check for horizontal jump points\n        if (this._jump(x + 1, y, x, y) || this._jump(x - 1, y, x, y)) {\n            return [x, y];\n        }\n    }\n    else {\n        throw new Error(\"Only horizontal and vertical movements are allowed\");\n    }\n\n    return this._jump(x + dx, y + dy, x, y);\n};\n\n/**\n * Find the neighbors for the given node. If the node has a parent,\n * prune the neighbors based on the jump point search algorithm, otherwise\n * return all available neighbors.\n * @return {Array<Array<number>>} The neighbors found.\n */\nJPFNeverMoveDiagonally.prototype._findNeighbors = function(node) {\n    var parent = node.parent,\n        x = node.x, y = node.y,\n        grid = this.grid,\n        px, py, nx, ny, dx, dy,\n        neighbors = [], neighborNodes, neighborNode, i, l;\n\n    // directed pruning: can ignore most neighbors, unless forced.\n    if (parent) {\n        px = parent.x;\n        py = parent.y;\n        // get the normalized direction of travel\n        dx = (x - px) / Math.max(Math.abs(x - px), 1);\n        dy = (y - py) / Math.max(Math.abs(y - py), 1);\n\n        if (dx !== 0) {\n            if (grid.isWalkableAt(x, y - 1)) {\n                neighbors.push([x, y - 1]);\n            }\n            if (grid.isWalkableAt(x, y + 1)) {\n                neighbors.push([x, y + 1]);\n            }\n            if (grid.isWalkableAt(x + dx, y)) {\n                neighbors.push([x + dx, y]);\n            }\n        }\n        else if (dy !== 0) {\n            if (grid.isWalkableAt(x - 1, y)) {\n                neighbors.push([x - 1, y]);\n            }\n            if (grid.isWalkableAt(x + 1, y)) {\n                neighbors.push([x + 1, y]);\n            }\n            if (grid.isWalkableAt(x, y + dy)) {\n                neighbors.push([x, y + dy]);\n            }\n        }\n    }\n    // return all neighbors\n    else {\n        neighborNodes = grid.getNeighbors(node, DiagonalMovement.Never);\n        for (i = 0, l = neighborNodes.length; i < l; ++i) {\n            neighborNode = neighborNodes[i];\n            neighbors.push([neighborNode.x, neighborNode.y]);\n        }\n    }\n\n    return neighbors;\n};\n\nmodule.exports = JPFNeverMoveDiagonally;\n\n},{\"../core/DiagonalMovement\":3,\"./JumpPointFinderBase\":23}],22:[function(_dereq_,module,exports){\n/**\n * @author aniero / https://github.com/aniero\n */\nvar DiagonalMovement = _dereq_('../core/DiagonalMovement');\nvar JPFNeverMoveDiagonally = _dereq_('./JPFNeverMoveDiagonally');\nvar JPFAlwaysMoveDiagonally = _dereq_('./JPFAlwaysMoveDiagonally');\nvar JPFMoveDiagonallyIfNoObstacles = _dereq_('./JPFMoveDiagonallyIfNoObstacles');\nvar JPFMoveDiagonallyIfAtMostOneObstacle = _dereq_('./JPFMoveDiagonallyIfAtMostOneObstacle');\n\n/**\n * Path finder using the Jump Point Search algorithm\n * @param {Object} opt\n * @param {function} opt.heuristic Heuristic function to estimate the distance\n *     (defaults to manhattan).\n * @param {DiagonalMovement} opt.diagonalMovement Condition under which diagonal\n *      movement will be allowed.\n */\nfunction JumpPointFinder(opt) {\n    opt = opt || {};\n    if (opt.diagonalMovement === DiagonalMovement.Never) {\n        return new JPFNeverMoveDiagonally(opt);\n    } else if (opt.diagonalMovement === DiagonalMovement.Always) {\n        return new JPFAlwaysMoveDiagonally(opt);\n    } else if (opt.diagonalMovement === DiagonalMovement.OnlyWhenNoObstacles) {\n        return new JPFMoveDiagonallyIfNoObstacles(opt);\n    } else {\n        return new JPFMoveDiagonallyIfAtMostOneObstacle(opt);\n    }\n}\n\nmodule.exports = JumpPointFinder;\n\n},{\"../core/DiagonalMovement\":3,\"./JPFAlwaysMoveDiagonally\":18,\"./JPFMoveDiagonallyIfAtMostOneObstacle\":19,\"./JPFMoveDiagonallyIfNoObstacles\":20,\"./JPFNeverMoveDiagonally\":21}],23:[function(_dereq_,module,exports){\n/**\n * @author imor / https://github.com/imor\n */\nvar Heap       = _dereq_('heap');\nvar Util       = _dereq_('../core/Util');\nvar Heuristic  = _dereq_('../core/Heuristic');\nvar DiagonalMovement = _dereq_('../core/DiagonalMovement');\n\n/**\n * Base class for the Jump Point Search algorithm\n * @param {object} opt\n * @param {function} opt.heuristic Heuristic function to estimate the distance\n *     (defaults to manhattan).\n */\nfunction JumpPointFinderBase(opt) {\n    opt = opt || {};\n    this.heuristic = opt.heuristic || Heuristic.manhattan;\n    this.trackJumpRecursion = opt.trackJumpRecursion || false;\n}\n\n/**\n * Find and return the path.\n * @return {Array<Array<number>>} The path, including both start and\n *     end positions.\n */\nJumpPointFinderBase.prototype.findPath = function(startX, startY, endX, endY, grid) {\n    var openList = this.openList = new Heap(function(nodeA, nodeB) {\n            return nodeA.f - nodeB.f;\n        }),\n        startNode = this.startNode = grid.getNodeAt(startX, startY),\n        endNode = this.endNode = grid.getNodeAt(endX, endY), node;\n\n    this.grid = grid;\n\n\n    // set the `g` and `f` value of the start node to be 0\n    startNode.g = 0;\n    startNode.f = 0;\n\n    // push the start node into the open list\n    openList.push(startNode);\n    startNode.opened = true;\n\n    // while the open list is not empty\n    while (!openList.empty()) {\n        // pop the position of node which has the minimum `f` value.\n        node = openList.pop();\n        node.closed = true;\n\n        if (node === endNode) {\n            return Util.expandPath(Util.backtrace(endNode));\n        }\n\n        this._identifySuccessors(node);\n    }\n\n    // fail to find the path\n    return [];\n};\n\n/**\n * Identify successors for the given node. Runs a jump point search in the\n * direction of each available neighbor, adding any points found to the open\n * list.\n * @protected\n */\nJumpPointFinderBase.prototype._identifySuccessors = function(node) {\n    var grid = this.grid,\n        heuristic = this.heuristic,\n        openList = this.openList,\n        endX = this.endNode.x,\n        endY = this.endNode.y,\n        neighbors, neighbor,\n        jumpPoint, i, l,\n        x = node.x, y = node.y,\n        jx, jy, dx, dy, d, ng, jumpNode,\n        abs = Math.abs, max = Math.max;\n\n    neighbors = this._findNeighbors(node);\n    for(i = 0, l = neighbors.length; i < l; ++i) {\n        neighbor = neighbors[i];\n        jumpPoint = this._jump(neighbor[0], neighbor[1], x, y);\n        if (jumpPoint) {\n\n            jx = jumpPoint[0];\n            jy = jumpPoint[1];\n            jumpNode = grid.getNodeAt(jx, jy);\n\n            if (jumpNode.closed) {\n                continue;\n            }\n\n            // include distance, as parent may not be immediately adjacent:\n            d = Heuristic.octile(abs(jx - x), abs(jy - y));\n            ng = node.g + d; // next `g` value\n\n            if (!jumpNode.opened || ng < jumpNode.g) {\n                jumpNode.g = ng;\n                jumpNode.h = jumpNode.h || heuristic(abs(jx - endX), abs(jy - endY));\n                jumpNode.f = jumpNode.g + jumpNode.h;\n                jumpNode.parent = node;\n\n                if (!jumpNode.opened) {\n                    openList.push(jumpNode);\n                    jumpNode.opened = true;\n                } else {\n                    openList.updateItem(jumpNode);\n                }\n            }\n        }\n    }\n};\n\nmodule.exports = JumpPointFinderBase;\n\n},{\"../core/DiagonalMovement\":3,\"../core/Heuristic\":5,\"../core/Util\":7,\"heap\":1}]},{},[8])\n(8)\n});\n\n//# sourceURL=webpack://bma/./src/pathfinding.js?");

/***/ })

/******/ });