\chapter{Theorie der Pathfinding-Algorithmen}

\section{Grundwissen}

\subsection{Was sind Algorithmen}

Ein Algorithmus beschreibt eine abstrakte Form eines Aufgabenlösungsweg.
Er besteht aus klaren Handlungsvorschriften, die in Form einer Kette
oder Reihe in Einzelschritten abgearbeitet werden müssen, um ein Problem
zu lösen. Ein Algorithmus kann den Satzaufbau einer Sprache
vorschreiben(Subjekt, Verb, Objekt) oder die Herstellung eines Gerichts
in der Küche als Kochrezept. Es wird immer eine bestimmte Eingabe in
eine bestimmte Ausgabe verarbeitet und das Ergebnis ist immer das
gleiche(wie eine Funktion in der Mathematik).

Es gibt sehr einfache Algorithmen, wie Verhaltensregeln oder Gesetze, in
denen man nachschauen kann, wie man sich in welcher Situation verhält
oder was erlaubt ist. Schwierigere Algorithmen findet man eher in der
Mathematik, Datenanalyse oder auch im Bewusstsein der Menschen.
\cite[Wikipedia, 2018]{wikialgo}

\subsection{Was ist ein Pathfinding Algorithmus}

Die Pathfinding Algorithmen sind eine Unterklasse der Algorithmen, sie
spezialisieren sich auf die suche des Optimalen Weges von einem Punkt A
zu einem Punkt B in einem Raum. Der Raum oder die Matrix kann hierbei
zweidimensional oder dreidimensional sein, in dieser Arbeit befassen wir
uns nur um die zweidimensionalen Pathfinding Algorithmen.

Bei Computerspielen kann der Raum das Spielfeld sein, wo unter anderem
eine Computergesteuerte Person(Künstliche Intelligenz = KI) immer auf
den Spieler zu läuft und ihn in einem definierten Abstand umkreis.

Bei unserem heutigen Internet infrastruktur helfen Pathfinding
Algorithmen unsere Daten über Routenplanung effizient von unserem
Computer zum Server der aufgerufen Homepage zu leiten und wieder zurück.

Die Pathfinding-Algorithmen suchen sich generell den kostengünstigsten
oder kürzesten Weg mit wenig Hindernissen aus. Ein Vogel kann mühelos
über einen Berg fliegen und legt bloss die direkte Luftlinie als
Wegstrecke zurück, wir Menschen müssen meistens um den Berg herum reisen
oder ihn in Schlangenlinien Förmigen Wanderwege überwinden.

Ob dieser Wanderweg der Optimalste ist, hängt von verschiedenen Faktoren
ab, eventuell gibt es sinnvollere Wege zum Ziel.

Einer dieser Faktoren kann sein:

\begin{itemize}
\item
  Man möchte am schnellsten am Ziel sein, vorzugsweise sucht man sich
  eine Öffentliche Fortbewegung wie ein Bus.(Zeit-Optimierung)
\item
  Man hat nicht unbegrenzt Geld und sucht sich den billigsten Weg
  heraus(Kosten-Optimierung).
\item
  Man möchte auf der Wanderung von gewissen Orten Bilder mit der Kamera
  festhalten(Weg-Optimierung)
\end{itemize}

Man beachte, dass egal welcher Weg ausgewählt wurde, dieser immer Vor-
und Nachteile hat. Dies kann man unter einem Kuchendiagramm vorstellen,
es gibt drei Parteien: Zeitoptimierung, Kostenoptimierung und
Wegoptimierung. Egal für welche Partei man bevorzugt den Kuchen
unterteilt, die anderen werden darunter leiden.
\cite[Wikipedia, 2018]{wikipath}

\section{Einführung der Graphen}

Pathfinding-Algorithmus ``sehen'' keine Wände oder Start- und
Zielpunkte. Sie verarbeiten lediglich eingegebene Daten in ausgehende
Daten. In unserer Webapplikation vereinfachen die
Pathfinding-Algorithmen die Darstellung des Raumes in nicht-negative
(siehe Kapitel Nicht Negativ gewichtet) Graphen. Daraus kann abgeleitet
werden, das die Pathfinding Algorithmen komplett unabhängig von der
visuellen Darstellung des Raumes arbeiten.
\cite[Andreas Hofmann, 2013]{pfbsc}

\subsection{Was ist ein Graph: Graphentheorie und Pathfinder}

Ein Graph ist eine mathematische Struktur zur Darstellung abstrakter
Beziehungsstrukturen und besteht aus zwei Elementen: Ecken/Knoten (engl.
vertices) und Kanten (englisch edges). Jede Kante verbindet exakt zwei
Ecken, es können aber mehrere Kanten auf eine Ecke verweisen. Jeder
angeschaute Knoten vom Algorithmus muss über mindesten eine Verbindung
erreichbar sein.

Die Knoten stellen bei unserer Anwendung die $x$- und $y$-Koordinaten des Raums
dar und die Kanten die Verbindungen der einzelnen Felder. Somit hat ein
Knoten bei Ausführung des bestimmten Algorithmus 4 Kanten. Wenn dem
Pathfinder die Diagonale zugelassen werden, gelten für die Knoten 8
Kanten.
\cite[Franz Embacher, 2003]{uniwiengraphen}

\subsection{Nicht negativ gewichtet}

In der allgemeinen Graphentheorie sind negativ gewichtete Graphen
erlaubt. Bei den Pathfindern jedoch nicht, da es keine negativen
Distanzen gibt. Von Punkt A nach B ist eine positive Gewichtung der
Strecke und der Rückweg von B nach A legt auch ein Positive Gewichtung
der Strecke in den Knoten.
\cite[Krumke; Noltemeier; Schwarz; Wirth, 2000, S. 76]{graphtheoryconcepts}

\subsection{Pathfinding-Graphen}

In unserem Raster kann man die Graphenstruktur wie ein Schachbrett
vorstellen, es beginnt am start und sucht Graph um Graph nach dem Ziel.
In jedem Graph wird gespeichert von wo wessen nachbar Graph man kam und
wie weit man vom Startpunkt entfernt ist. Findet man den gleichen Graph
ein zweites mal, durch einen anderen Weg, wird der schnellere Weg zum
start in den Graph geschrieben. Findet die Struktur das Ziel, so
verweist jeder Vorgehender Graph auf den Graph davor. Diese Graphen
Kette zeigt dann vom Ziel zum Start.
\cite[Vinther, Vinther, 2015, S. 22]{pftwodim}

%4.3 \#\#\#genauer nachkontrollieren\#\#\#\#\#\#
%
\section{Heuristiken}

Im Allgemeinen können Algorithmen auf eine Heuristik zugreifeifen um
Optimierter nach einem Weg zu suchen. Der begriff ``Heuristik'' bedeutet
mit begrenztem Wissen oder unvollständiger Informationen die Optimale
Lösung zu schätzen im Vorhinein. Anderst gesagt teilt die heuristik dem
Algorithmus mit, welcher Graph am Wahrscheindlicshstem zum Zielpunkt
Führt.

Bei den Ausgewählten Algorithmen beim Vergleichen benutzt der A* und
BestFirstFinder die Manhattan Heuristik und der BreadthFirstFinder
keine. Der BreadthFirstFinder benutzt in seinem Standard code nie eine
Heuristik. Die Manhattan Heuristik, auch Cityblock-metrix, wurde
Ausgewählt, da das Raster dieser Berufsmaturitätsarbeit an einem Schachbrett
ähnelt mit immer dem gleichen Abstand zwischen den Feldern.
Die Manhattan Heuristik ist definiert durch:
\begin{equation}
d\big((x_1,y_1),(x_2,y_2)\big) = |x_1 - x_{2}| + |y_{1} - y_{2}|
\end{equation}
für alle Punkte im Raster. Die Distanz d ist gleich der länge aller Wege, die $P_1$ und $P_2$ entlang der Horizontaler und Vertikaler Linie Verbindet. $P_2$ ist bei dieser Arbeit immer der Zielpunkt und $P_1$ der
Aktuelle Standpunkt im Raster. \cite[Patel, 2019]{heuristicsredblob}

\section{Auswahl der Pathfinding-Algorithmen}

Das Autorenteam hat sich für folgende Pathfinding-Algorithmen
entschieden, weil diese im Vorfeld schon ersichtliche unterschiedliche
Wege ausgewählt haben im gleichen vorgegebenen Raster.

\subsection{A*}

Der A*-Algorithmus, gesprochen ``A Star'', untersucht mithilfe einer
Heuristik immer den wahrscheinlich nächsten Knoten im Raster der zum
Ziel führt. Jedem Nachbarknoten wird zuerst einen Wert $d$ zugeordnet, der
angibt, wie lange der Weg geschätzt von diesem Knoten zum Ziel führt. Der Wert $d$
wird mit der Manhattan heuristik ausgerechnet. Jeder Graph mit einem $d$-Wert 
wird in eine liste eingetragen. Der A-Star rechnet immer die neuen
Nachbarn aus des Graphen mit dem kleinsten $d$-Wert. Dadurch kann
vorkommen, das nach langer Suche, der A-Star plötzlich wieder einige
Graphen zurückspringen muss, da die neu berechneten $d$-Werte grösser als
ein früherer gefundener $d$-Wert ist.
\cite[Schmidt, Fuchs]{asterngeo}

\subsubsection{Funktionsweise}

Alle Graphen werden in drei Listen eingetragen:

\begin{itemize}
\item
  unbekannte Knoten
\end{itemize}

Bei Starten der Suche sind alle Knoten im Raster in dieser Liste.

\begin{itemize}
\item
  bekannte Knoten
\end{itemize}

\begin{quote}
Wurde einem Knoten den d Wert der Heuristik zugeteilt, wird er in diese
Liste mit dem d Wert eingetragen. Aus dieser Liste wird immer der Knoten
mit kleinstem d Wert ausgewählt, der als nächstes angeschaut wird.
\end{quote}

\begin{itemize}
\item
  untersuchte Knoten
\end{itemize}

\begin{quote}
Zu diesem Knoten wurde der kleinste Weg herausgefunden, d.h. alle
Nachbarknoten sind in der Liste mit bekannten Knoten.
\end{quote}

Jeder der Gefundenen Knoten besitzt einen Verweis auf den
Vorgängerknoten. Wird das Ziel erreicht, kann mit hilfe dieses Zeigers
der Pfad bis zum Start ausgegeben werden.
\cite[Schmidt, Fuchs]{asterngeo}

\subsubsection{Beispiel}

Blau ist Startpunkt und Grün Zielpunkt, Diagonale Verbindungen sind
nicht verfügbar.



\begin{table}[H]
  \begin{center}
    \begin{tabular}{ c  p{8cm}  p{2cm}   p{2cm} }
      \toprule
      Bild & Ausführung & Bekannte Knoten & Untersuchte Knoten \\ 
      \cmidrule(r){1-1}\cmidrule(lr){2-2}\cmidrule(l){3-3}\cmidrule(l){4-4}
      \raisebox{-\totalheight}{\includegraphics[width=0.20\textwidth]{image1}}
      & 
      Schreibt Startpunkt in Bekannte Liste mit Distanz Wert.
      & 
      (4/1) d = 4
      & 
      --
      \\ \bottomrule %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
      \raisebox{-\totalheight}{\includegraphics[width=0.20\textwidth]{image2}}
      & 
      Berechne Distanz Wert aller Nachbarn(Rot markiert) und schreibe diese in die bekannte Knoten-Liste. Verweise auf den Vorgängigen Knoten(Schwarzer Balken).Da (4/1) Alle bekannte Nachbarn hat, wird dieser Knoten in die untersuchten Knoten-Liste verschoben. Der Knopf mit den tiefsten d Wert wird Angeschaut und der Prozess wird wiederholt.
      & 
      (3/1) d = 3
      (5/1) d = 5
      (4/2) d = 5
      & 
      (4/1) d = 4
      \\ \bottomrule %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
      \raisebox{-\totalheight}{\includegraphics[width=0.20\textwidth]{image3}}
      & 
      Da der Graph(3/1) Alle bekannten Nachbarn hat, wird dieser Knoten in der untersuchten Knoten-Liste verschoben.
      & 
      (3/0) d = 2
      (2/1) d = 2
      (5/1) d = 5
      (4/2) d = 5
      & 
      (3/1) d = 3
      (4/1) d = 4
      \\ \bottomrule %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
      \raisebox{-\totalheight}{\includegraphics[width=0.20\textwidth]{image4}}
      & 
      Falls Graph(3/0) vor Graph(2/1) angeschaut wird(gleiche d Werte), wird dieser, da er keine gültigen Nachbarn hat, in die untersuchten Knoten-Liste geschrieben.
      & 
      (2/1) d = 2
      (5/1) d = 5
      (4/2) d = 5
      & 
      (3/0) d = 2
      (3/1) d = 3
      (4/1) d = 4
      \\ \bottomrule %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
      \raisebox{-\totalheight}{\includegraphics[width=0.20\textwidth]{image5}}
      & 
      Der Prozess wird weitergeführt. Die Listen werden kontinuierlich aktualisiert.
      & 
      (1/1) d = 1
      (2/2) d = 2
      (3/1) d = 3
      (5/1) d = 5
      (4/2) d = 5
      & 
      (3/0) d = 2
      (2/1) d = 2
      (4/1) d = 4
      \\ \bottomrule %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
      \raisebox{-\totalheight}{\includegraphics[width=0.20\textwidth]{image6}}
      & 
      Der A-Star hat das Ziel erreicht und muss noch den einzelnen Graphen zurück folgen bis zum Start und kennt somit den Weg.
      & 
      (1/0) d = 0
      (0/1) d = 2
      (1/2) d = 2
      (2/2) d = 2
      (3/1) d = 3
      (5/1) d = 5
      (4/2) d = 5
      & 
      (1/1) d = 1
      (3/0) d = 2
      (2/1) d = 2
      (4/1) d = 4
      \\ \bottomrule %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \end{tabular}
  \end{center}
\end{table}
\begin{table}[H]
  \begin{center}
    \begin{tabular}{ c  p{8cm}  p{2cm}   p{2cm} }
      \toprule
      Bild & Ausführung & Bekannte Knoten & Untersuchte Knoten \\ 
      \cmidrule(r){1-1}\cmidrule(lr){2-2}\cmidrule(l){3-3}\cmidrule(l){4-4}
      \raisebox{-\totalheight}{\includegraphics[width=0.20\textwidth]{image7}}
      & 
      Die Suche ist Beendet
      & 
      --
      & 
      --
      \\ \bottomrule %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \end{tabular}
  \end{center}
\end{table}


%\begin{longtable}[]{@{}llll@{}}
%\toprule
%\endhead
%\textbf{Bild} & \textbf{Ausführung} & \textbf{bekannte Knoten} &
%\textbf{untersuchte Knoten}\tabularnewline
%\includegraphics[width=2.10417in,height=2.09722in]{image1.png} &
%Schreibt Startpunkt in Bekannte Liste mit Distanz Wert. & $(4,1) d = 4$ &
%-\tabularnewline
%\begin{minipage}[t]{2.09722in}\raggedright
%\includegraphics[width=2.10417in,height=2.09722in]{image2.png}\strut
%\end{minipage} & \begin{minipage}[t]{2.09722in}\raggedright
%Berechne Distanz Wert aller Nachbarn(Rot markiert) und schreibe diese in
%die bekannte Knoten-Liste. Verweise auf den Vorgängigen Knoten(Schwarzer
%Balken).Da (4/1) Alle bekannte Nachbarn hat, wird dieser Knoten in die
%untersuchten Knoten-Liste verschoben. Der Knopf mit den tiefsten d Wert
%wird Angeschaut und der Prozess wird wiederholt.\strut
%\end{minipage} & \begin{minipage}[t]{0.22\columnwidth}\raggedright
%(3/1) d = 3
%
%(5/1) d = 5
%
%(4/2) d = 5\strut
%\end{minipage} & \begin{minipage}[t]{0.22\columnwidth}\raggedright
%(4/1) d = 4\strut
%\end{minipage}\tabularnewline
%\begin{minipage}[t]{0.22\columnwidth}\raggedright
%\includegraphics[width=2.10417in,height=2.09722in]{image3.png}\strut
%\end{minipage} & \begin{minipage}[t]{0.22\columnwidth}\raggedright
%Da der Graph(3/1) Alle bekannten Nachbarn hat, wird dieser Knoten in der
%untersuchten Knoten-Liste verschoben.\strut
%\end{minipage} & \begin{minipage}[t]{0.22\columnwidth}\raggedright
%(3/0) d = 2
%
%(2/1) d = 2
%
%(5/1) d = 5
%
%(4/2) d = 5\strut
%\end{minipage} & \begin{minipage}[t]{0.22\columnwidth}\raggedright
%(3/1) d = 3
%
%(4/1) d = 4\strut
%\end{minipage}\tabularnewline
%\begin{minipage}[t]{0.22\columnwidth}\raggedright
%\includegraphics[width=2.10417in,height=2.09722in]{image4.png}\strut
%\end{minipage} & \begin{minipage}[t]{0.22\columnwidth}\raggedright
%Falls Graph(3/0) vor Graph(2/1) angeschaut wird(gleiche d Werte), wird
%dieser, da er keine gültigen Nachbarn hat, in die untersuchten
%Knoten-Liste geschrieben.\strut
%\end{minipage} & \begin{minipage}[t]{0.22\columnwidth}\raggedright
%(2/1) d = 2
%
%(5/1) d = 5
%
%(4/2) d = 5\strut
%\end{minipage} & \begin{minipage}[t]{0.22\columnwidth}\raggedright
%(3/0) d = 2
%
%(3/1) d = 3
%
%(4/1) d = 4\strut
%\end{minipage}\tabularnewline
%\begin{minipage}[t]{0.22\columnwidth}\raggedright
%\includegraphics[width=2.10417in,height=2.09722in]{image5.png}\strut
%\end{minipage} & \begin{minipage}[t]{0.22\columnwidth}\raggedright
%Der Prozess wird weitergeführt. Die Listen werden kontinuierlich
%aktualisiert.\strut
%\end{minipage} & \begin{minipage}[t]{0.22\columnwidth}\raggedright
%(1/1) d = 1
%
%(2/2) d = 2
%
%(3/1) d = 3
%
%(5/1) d = 5
%
%(4/2) d = 5\strut
%\end{minipage} & \begin{minipage}[t]{0.22\columnwidth}\raggedright
%(3/0) d = 2
%
%(2/1) d = 2
%
%(4/1) d = 4\strut
%\end{minipage}\tabularnewline
%\begin{minipage}[t]{0.22\columnwidth}\raggedright
%\includegraphics[width=2.10417in,height=2.09722in]{image6.png}\strut
%\end{minipage} & \begin{minipage}[t]{0.22\columnwidth}\raggedright
%Der A-Star hat das Ziel erreicht und muss noch den einzelnen Graphen
%zurück folgen bis zum Start und kennt somit den Weg.\strut
%\end{minipage} & \begin{minipage}[t]{0.22\columnwidth}\raggedright
%(1/0) d = 0
%
%(0/1) d = 2
%
%(1/2) d = 2
%
%(2/2) d = 2
%
%(3/1) d = 3
%
%(5/1) d = 5
%
%(4/2) d = 5\strut
%\end{minipage} & \begin{minipage}[t]{0.22\columnwidth}\raggedright
%(1/1) d = 1
%
%(3/0) d = 2
%
%(2/1) d = 2
%
%(4/1) d = 4\strut
%\end{minipage}\tabularnewline
%\includegraphics[width=2.10417in,height=2.09722in]{image7.png} &
%Die Suche ist Beendet. & - & -\tabularnewline
%\bottomrule
%\end{longtable}
%
%\textbf{BestFirstFinder}
%
%Wie der Name schon sagt sucht dieser Pathfind-Algorithmus nach dem
%erstbesten Weg zum Ziel. Im Vergleich zum A-Star hat dieser bloss eine
%Liste mit offenen Knoten. Mit der Manhattan Heuristik wird nur der Weg
%zum tiefsten Distanz wert Graph in diese Liste eingetragen, somit schaut
%der Bestfirstfinder nicht auf alle nachbarknoten.
%
%\textbf{Funktionsweise}
%
%Es wird eine Liste für die Offenen Knoten eröffnet und der Startknoten
%wird eingetragen. Auch hier verweist jeder Knoten auf seinen Vorgänger.
%Der beste Knoten aus der Liste wird n genannt. Schau die Nachbarn von n
%an und bewerte diese mit der Heuristik, der beste Wert wird in die Liste
%eingetragen und der Ablauf wird wiederholt. Kommt ein Knoten, der
%angeschaut wird, nicht weiter, wird der zweitbeste Graph in der Liste
%Angeschaut. Es kann einer weiten Liste hinzugefügt werden, die
%geschlossene Liste, die den Lösungsweg direkt mit Abspeichert und
%verhindert, dass dieser Algorithmus nicht in einer Endlosschleife endet.
%
%{[}https://developer.roblox.com/articles/Best-first-search\#Pseudo\_Code{]}
%
%\textbf{Beispiel}
%
%Blau ist Startpunkt und Grün Zielpunkt, Diagonale Verbindungen sind
%nicht verfügbar.
%
%\begin{longtable}[]{@{}lll@{}}
%\toprule
%\endhead
%Bild & Ausführung & Liste\tabularnewline
%\includegraphics[width=1.9375in,height=1.93056in]{media/image1.png} &
%Schreibe Startpunkt in die Liste. & (4/1) d = 4\tabularnewline
%\begin{minipage}[t]{0.30\columnwidth}\raggedright
%\includegraphics[width=1.9375in,height=1.93056in]{media/image8.png}\strut
%\end{minipage} & \begin{minipage}[t]{0.30\columnwidth}\raggedright
%Wähle den besten Nachbar, anhand seiner Distanz Wert d, hier ist es
%Graph(3/1). Schreibe diesen Wert in die Liste.\strut
%\end{minipage} & \begin{minipage}[t]{0.30\columnwidth}\raggedright
%(3/1) d = 3
%
%(4/1) d = 4\strut
%\end{minipage}\tabularnewline
%\begin{minipage}[t]{0.30\columnwidth}\raggedright
%\includegraphics[width=1.9375in,height=1.93056in]{media/image9.png}\strut
%\end{minipage} & \begin{minipage}[t]{0.30\columnwidth}\raggedright
%Wiederhole die Ausführung bis das Ziel erreicht wurde.\strut
%\end{minipage} & \begin{minipage}[t]{0.30\columnwidth}\raggedright
%(2/1) d = 2
%
%(3/1) d = 3
%
%(4/1) d = 4\strut
%\end{minipage}\tabularnewline
%\begin{minipage}[t]{0.30\columnwidth}\raggedright
%\includegraphics[width=1.9375in,height=1.93056in]{media/image10.png}\strut
%\end{minipage} & \begin{minipage}[t]{0.30\columnwidth}\raggedright
%\strut
%\end{minipage} & \begin{minipage}[t]{0.30\columnwidth}\raggedright
%(1/1) d = 1
%
%(2/1) d = 2
%
%(3/1) d = 3
%
%(4/1) d = 4\strut
%\end{minipage}\tabularnewline
%\begin{minipage}[t]{0.30\columnwidth}\raggedright
%\includegraphics[width=1.9375in,height=1.93056in]{media/image11.png}\strut
%\end{minipage} & \begin{minipage}[t]{0.30\columnwidth}\raggedright
%Der Weg wurde gefunden\strut
%\end{minipage} & \begin{minipage}[t]{0.30\columnwidth}\raggedright
%(1/0) d = 0
%
%(1/1) d = 1
%
%(2/1) d = 2
%
%(3/1) d = 3
%
%(4/1) d = 4\strut
%\end{minipage}\tabularnewline
%\bottomrule
%\end{longtable}
%
%\textbf{BreadthFirstFinder}
%
%Der BreadthFirstFinder benutzt keine Heuristik, da er sein Weg über die
%Breitensuche findet. Er Expandiert in jede Richtung gleich schnell und
%bewegt sich nicht wie die anderen zwei Pathfinder in Richtung Ziel. Wenn
%alle Knoten mit der gleichen Distanz zum Start angeschaut sind, beginnt
%er mit der Suche der eins weiter entfernten Knoten. Dieser Pathfinder
%besitzt eine Liste in der er die noch zu bearbeitenden Knoten speichert,
%beginnend mit dem am Start nächsten Knoten.
%
%{[}https://brilliant.org/wiki/breadth-first-search-bfs/{]}
%
%\textbf{Funktionsweise}
%
%Beginne beim Startpunkt und Speichere ihn in die Warteliste. Schaue am
%obersten Knoten in der Warteschlange dessen Nachbarn an und prüfe ob
%eines der Ausgewählten Knoten der Zielknoten ist. Ist dies der Fall wird
%die Suche Abgebrochen, da der Weg Gefunden wurde. Falls keiner der
%Knoten der Zielknoten ist, speichere die neuen Knoten in die Warteliste
%an Hinterste Stelle und entferne den Ausgewählten Knoten. Jeder Knote
%der neu gefunden wird zeigt auf den ausgewählten Knoten.
%
%{[}https://brilliant.org/wiki/breadth-first-search-bfs/{]}
%
%\textbf{Beispiel}
%
%Blau ist Startpunkt und Grün Zielpunkt, Diagonale Verbindungen sind
%nicht verfügbar.
%
%\begin{longtable}[]{@{}lll@{}}
%\toprule
%\endhead
%\textbf{Bild} & \textbf{Ausführung} & \textbf{Liste}\tabularnewline
%\includegraphics[width=1.9375in,height=1.93056in]{media/image1.png} &
%Schreibe den Startpunkt in die Liste. & (4/1)\tabularnewline
%\begin{minipage}[t]{0.30\columnwidth}\raggedright
%\includegraphics[width=1.9375in,height=1.93056in]{media/image12.png}\strut
%\end{minipage} & \begin{minipage}[t]{0.30\columnwidth}\raggedright
%Schaue alle Nachbarn an und speichere diese in die Liste an hinterste
%Stelle. Falls keiner der neuen Knoten das Ziel ist, führe suche fort.
%Jeder neue Graph verweist auf den Vorgänger. Entferne aktuellen
%ausgewählten Knoten(4/1).\strut
%\end{minipage} & \begin{minipage}[t]{0.30\columnwidth}\raggedright
%(3/1)
%
%(5/1)
%
%(2/1)\strut
%\end{minipage}\tabularnewline
%\begin{minipage}[t]{0.30\columnwidth}\raggedright
%\includegraphics[width=1.9375in,height=1.93056in]{media/image13.png}\strut
%\end{minipage} & \begin{minipage}[t]{0.30\columnwidth}\raggedright
%Schaue alle Nachbarn der zurzeit in der Liste stehenden Knoten und
%Wiederhole alles vom oben genannte.\strut
%\end{minipage} & \begin{minipage}[t]{0.30\columnwidth}\raggedright
%(3/1)
%
%(2/1)
%
%(5/1)\strut
%\end{minipage}\tabularnewline
%\begin{minipage}[t]{0.30\columnwidth}\raggedright
%\includegraphics[width=1.9375in,height=1.93056in]{media/image14.png}\strut
%\end{minipage} & \begin{minipage}[t]{0.30\columnwidth}\raggedright
%\strut
%\end{minipage} & \begin{minipage}[t]{0.30\columnwidth}\raggedright
%(1/1)
%
%(2/2)\strut
%\end{minipage}\tabularnewline
%\begin{minipage}[t]{0.30\columnwidth}\raggedright
%\includegraphics[width=1.9375in,height=1.93056in]{media/image15.png}\strut
%\end{minipage} & \begin{minipage}[t]{0.30\columnwidth}\raggedright
%Das Ziel Wurde Gefunden und die Suche kann beendet werden. Folgen vom
%Ziel zum Start und gib den Lösungsweg aus.\strut
%\end{minipage} & \begin{minipage}[t]{0.30\columnwidth}\raggedright
%(0/1)
%
%(1/0)
%
%(1/2)
%
%(2/3)\strut
%\end{minipage}\tabularnewline
%\includegraphics[width=1.9375in,height=1.93056in]{media/image11.png} &
%Lösung & -\tabularnewline
%\bottomrule
%\end{longtable}
%
%\textbf{Vor- und Nachteile der einzelnen Pathfinder}
%
%Anhand der Beispiele am gleichen Raster sieht man sehr gut, dass alle
%drei Pathfinder den gleichen Weg finden durch unterschiedliche Methoden.
%
%Der A-Star führt viele Heuristik Berechnungen durch, da er von jedem
%Knoten die Distanz zum Ziel speichern möchte. Dies erfordert mehr
%Rechenleistung beziehungsweise mehr Operationen als die beiden anderen.
%Bei Komplexeren Raste wird er jedoch immer den besseren Weg finden.
%
%Der BestFirstFinder untersucht nur den zuerst gefunden besten Weg und
%sucht daher zuerst in der tiefe. Er braucht weniger Rechenleistung als
%der A-Star, kann aber mühe bekommen, falls der erst gesuchte Weg in eine
%Sackgasse führt. In diesem Beispiel musste er weniger Knoten anschauen
%als der A-Star, obwohl er die gleiche Heuristik benutzt.
%
%Der BreadthFirstFinder suche alle ihm am nächsten gelegenen Knoten ab
%und wird immer auf eine Lösung kommen auf Kosten der ``unnötigen''
%Knoten die weiter entfernt zum Ziel als seine aktuelle Position. Die
%Warteliste wird mit jeder neuen Expansion um ein vielfaches grösser und
%die Expansion Erweiterung wird über die Dauer langsamer.
